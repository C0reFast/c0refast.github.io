<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C0reFast记事本</title>
  <icon>https://www.gravatar.com/avatar/7b99452f171f3120130de41cdc5b9541</icon>
  <subtitle>to inspire confidence in somebody.</subtitle>
  <link href="https://www.ichenfu.com/atom.xml" rel="self"/>
  
  <link href="https://www.ichenfu.com/"/>
  <updated>2024-12-25T10:38:38.432Z</updated>
  <id>https://www.ichenfu.com/</id>
  
  <author>
    <name>陈孚</name>
    <email>topcenfu[at]qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IPIP隧道导致的DPDK收包RSS队列不均匀问题</title>
    <link href="https://www.ichenfu.com/2024/12/25/rss-not-balanced-caused-by-ipip-tunnel/"/>
    <id>https://www.ichenfu.com/2024/12/25/rss-not-balanced-caused-by-ipip-tunnel/</id>
    <published>2024-12-25T12:56:47.000Z</published>
    <updated>2024-12-25T10:38:38.432Z</updated>
    
    <content type="html"><![CDATA[<p>最近线上出现一些VM网卡收包队列不均匀的问题，即使是将网卡队列中断均匀的绑定到各个CPU上，依然会出现某个核特别高的情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.9</span> hi,  <span class="token number">0.9</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">97.5</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.8</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu2  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.1</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.9</span> si,  <span class="token number">0.0</span> st%Cpu3  <span class="token builtin class-name">:</span>  <span class="token number">0.9</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.9</span> si,  <span class="token number">0.0</span> st%Cpu4  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu5  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">97.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.9</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu6  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">97.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.9</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu7  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu8  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">46.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">3.4</span> hi, <span class="token number">50.3</span> si,  <span class="token number">0.0</span> st%Cpu9  <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">97.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.9</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu10 <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu11 <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.1</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.9</span> si,  <span class="token number">0.0</span> st%Cpu12 <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu13 <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.1</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.9</span> si,  <span class="token number">0.0</span> st%Cpu14 <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st%Cpu15 <span class="token builtin class-name">:</span>  <span class="token number">0.0</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">1.7</span> si,  <span class="token number">0.0</span> st<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>能看到其他核大部分还是比较均匀的，就是cpu8确实比其他核高很多。经过了一些排查，发现和VM使用了<code>IPIP Tunnel</code>有关。</p><span id="more"></span><p>用户的场景是，在网络入口处有一台机器充当负载均衡的角色，然后这台负载均衡再通过<code>IPIP Tunnel</code>将用户的请求转发到这台VM，由于<code>IPIP</code>的原理是在原有的IP包基础上再“套”一层IP包头，导致RSS计算的Hash的之后只能看到外层的IP，所以即使内层IP包的五元组分布非常均匀，也会出现所以隧道的流量都跑到一个核上的情况。</p><p>为了网络的灵活性，VM的网络流量，是经过了一个DPDK程序进行转发的，这个DPDK程序逻辑非常简单，就是从网卡对应的rx队列N接收数据包，然后发送到VM对应的rx队列N，因此如果VM的接收队列不平衡，也就意味着从网卡收包的时候就是不均匀的。</p><p>那怎么解决这个问题呢，很显然的一个思路是，当DPDK收包之后，重新计算一下数据包的Hash，在计算过程中，如果发现数据包是一个IPIP数据包，就按内层IP头去计算Hash，然后再根据这个Hash计算VM的接受队列，并把包转发到对应队列。在这种情况下，不管从网卡收包是否是均衡的，到VM的流量基本就会是均衡的。这样确实会非常灵活（这也是当时多加一层DPDK而不是直接网卡直通的原因），但很显然DPDK程序的计算量增加了，对性能会有不小的影响。</p><p>那网卡能不能支持针对IPIP数据包提供个“更高级的”RSS算法呢？毕竟现在的网卡功能特性都比较多，功能也比较强大，很有可能可以直接在网卡层面直接实现支持基于隧道内层IP头进行RSS的能力，如果能通过网卡层面实现，那是最优解了。</p><p>跟网卡厂商交流之后，确认了网卡是支持这个特性的，而且，在使用Linux驱动收包的情况下，默认就是开启的，也就是说，如果使用的是网卡直通的模式，那直接就不会遇到这个问题。但我们使用了DPDK进行中转，默认是没有这个行为的，如果要开启基于IPIP Tunnel内层IP头进行RSS，需要给网卡下发这样一条流表：<code>flow create 0 group 0 ingress pattern eth / ipv4 proto is 4 / ipv4 / tcp / end actions rss queues 0 1 2 3 4 end level 2 / end</code>。简单翻译一下，就是通过流表去匹配<code>ipv4.proto == 4</code>(也就是IPIP Tunnel协议)的数据包，并让网卡以内层IP进行rss，并分配到<code>0 1 2 3 4</code>这几个队列中。</p><p>知道了这个规则，我们就可以用<code>testpmd</code>测试下了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">testpmd<span class="token operator">></span> <span class="token builtin class-name">set</span> fwd rxonlySet rxonly packet forwarding modetestpmd<span class="token operator">></span>testpmd<span class="token operator">></span> startrxonly packet forwarding - <span class="token assign-left variable">ports</span><span class="token operator">=</span><span class="token number">1</span> - <span class="token assign-left variable">cores</span><span class="token operator">=</span><span class="token number">1</span> - <span class="token assign-left variable">streams</span><span class="token operator">=</span><span class="token number">16</span> - NUMA support enabled, MP allocation mode: nativeLogical Core <span class="token number">1</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> forwards packets on <span class="token number">16</span> streams:  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">5</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">5</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">7</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">7</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">9</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">9</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">10</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">10</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">11</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">11</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">12</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">12</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">13</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">13</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">14</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">14</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">15</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">15</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  rxonly packet forwarding packets/burst<span class="token operator">=</span><span class="token number">32</span>  nb forwarding <span class="token assign-left variable">cores</span><span class="token operator">=</span><span class="token number">1</span> - nb forwarding <span class="token assign-left variable">ports</span><span class="token operator">=</span><span class="token number">1</span>  port <span class="token number">0</span>: RX queue number: <span class="token number">16</span> Tx queue number: <span class="token number">16</span>    Rx <span class="token assign-left variable">offloads</span><span class="token operator">=</span>0x0 Tx <span class="token assign-left variable">offloads</span><span class="token operator">=</span>0x10000    RX queue: <span class="token number">0</span>      RX <span class="token assign-left variable">desc</span><span class="token operator">=</span><span class="token number">4096</span> - RX <span class="token function">free</span> <span class="token assign-left variable">threshold</span><span class="token operator">=</span><span class="token number">64</span>      RX threshold registers: <span class="token assign-left variable">pthresh</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">hthresh</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token assign-left variable">wthresh</span><span class="token operator">=</span><span class="token number">0</span>      RX <span class="token assign-left variable">Offloads</span><span class="token operator">=</span>0x0    TX queue: <span class="token number">0</span>      TX <span class="token assign-left variable">desc</span><span class="token operator">=</span><span class="token number">4096</span> - TX <span class="token function">free</span> <span class="token assign-left variable">threshold</span><span class="token operator">=</span><span class="token number">0</span>      TX threshold registers: <span class="token assign-left variable">pthresh</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">hthresh</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token assign-left variable">wthresh</span><span class="token operator">=</span><span class="token number">0</span>      TX <span class="token assign-left variable">offloads</span><span class="token operator">=</span>0x10000 - TX RS bit <span class="token assign-left variable">threshold</span><span class="token operator">=</span><span class="token number">0</span>testpmd<span class="token operator">></span> stopTelling cores to stop<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> lcores to finish<span class="token punctuation">..</span>.  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">12</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">12</span> -------  RX-packets: <span class="token number">139389</span>         TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ---------------------- Forward statistics <span class="token keyword">for</span> port <span class="token number">0</span>  ----------------------  RX-packets: <span class="token number">139389</span>         RX-dropped: <span class="token number">0</span>             RX-total: <span class="token number">139389</span>  TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>             TX-total: <span class="token number">0</span>  ----------------------------------------------------------------------------  +++++++++++++++ Accumulated forward statistics <span class="token keyword">for</span> all ports+++++++++++++++  RX-packets: <span class="token number">139389</span>         RX-dropped: <span class="token number">0</span>             RX-total: <span class="token number">139389</span>  TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>             TX-total: <span class="token number">0</span>  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到默认情况下，所有的包全跑到<code>Queue=12</code>这个队列了。很显然默认情况下RSS是有些问题的，那就继续试试下发流表之后的情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">testpmd<span class="token operator">></span> flow create <span class="token number">0</span> group <span class="token number">0</span> ingress pattern eth / ipv4 proto is <span class="token number">4</span> / ipv4 / tcp / end actions rss queues <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> end level <span class="token number">2</span> / endFlow rule <span class="token comment">#0 created</span>testpmd<span class="token operator">></span> startrxonly packet forwarding - <span class="token assign-left variable">ports</span><span class="token operator">=</span><span class="token number">1</span> - <span class="token assign-left variable">cores</span><span class="token operator">=</span><span class="token number">1</span> - <span class="token assign-left variable">streams</span><span class="token operator">=</span><span class="token number">16</span> - NUMA support enabled, MP allocation mode: nativeLogical Core <span class="token number">1</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> forwards packets on <span class="token number">16</span> streams:  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">5</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">5</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">7</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">7</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">8</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">9</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">9</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">10</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">10</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">11</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">11</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">12</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">12</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">13</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">13</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">14</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">14</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  RX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">15</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> -<span class="token operator">></span> TX <span class="token assign-left variable">P</span><span class="token operator">=</span><span class="token number">0</span>/Q<span class="token operator">=</span><span class="token number">15</span> <span class="token punctuation">(</span>socket <span class="token number">0</span><span class="token punctuation">)</span> <span class="token assign-left variable">peer</span><span class="token operator">=</span>02:00:00:00:00:00  rxonly packet forwarding packets/burst<span class="token operator">=</span><span class="token number">32</span>  nb forwarding <span class="token assign-left variable">cores</span><span class="token operator">=</span><span class="token number">1</span> - nb forwarding <span class="token assign-left variable">ports</span><span class="token operator">=</span><span class="token number">1</span>  port <span class="token number">0</span>: RX queue number: <span class="token number">16</span> Tx queue number: <span class="token number">16</span>    Rx <span class="token assign-left variable">offloads</span><span class="token operator">=</span>0x0 Tx <span class="token assign-left variable">offloads</span><span class="token operator">=</span>0x10000    RX queue: <span class="token number">0</span>      RX <span class="token assign-left variable">desc</span><span class="token operator">=</span><span class="token number">4096</span> - RX <span class="token function">free</span> <span class="token assign-left variable">threshold</span><span class="token operator">=</span><span class="token number">64</span>      RX threshold registers: <span class="token assign-left variable">pthresh</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">hthresh</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token assign-left variable">wthresh</span><span class="token operator">=</span><span class="token number">0</span>      RX <span class="token assign-left variable">Offloads</span><span class="token operator">=</span>0x0    TX queue: <span class="token number">0</span>      TX <span class="token assign-left variable">desc</span><span class="token operator">=</span><span class="token number">4096</span> - TX <span class="token function">free</span> <span class="token assign-left variable">threshold</span><span class="token operator">=</span><span class="token number">0</span>      TX threshold registers: <span class="token assign-left variable">pthresh</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">hthresh</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token assign-left variable">wthresh</span><span class="token operator">=</span><span class="token number">0</span>      TX <span class="token assign-left variable">offloads</span><span class="token operator">=</span>0x10000 - TX RS bit <span class="token assign-left variable">threshold</span><span class="token operator">=</span><span class="token number">0</span>testpmd<span class="token operator">></span> stopTelling cores to stop<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> lcores to finish<span class="token punctuation">..</span>.  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">0</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">0</span> -------  RX-packets: <span class="token number">6001</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">1</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">1</span> -------  RX-packets: <span class="token number">5894</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">2</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">2</span> -------  RX-packets: <span class="token number">5931</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">3</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">3</span> -------  RX-packets: <span class="token number">5759</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">4</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">4</span> -------  RX-packets: <span class="token number">5821</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">5</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">5</span> -------  RX-packets: <span class="token number">5787</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">6</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">6</span> -------  RX-packets: <span class="token number">5893</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">7</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">7</span> -------  RX-packets: <span class="token number">5909</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">8</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">8</span> -------  RX-packets: <span class="token number">6013</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">9</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span> <span class="token number">9</span> -------  RX-packets: <span class="token number">5956</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">10</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">10</span> -------  RX-packets: <span class="token number">5735</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">11</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">11</span> -------  RX-packets: <span class="token number">5885</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">12</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">12</span> -------  RX-packets: <span class="token number">5771</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">13</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">13</span> -------  RX-packets: <span class="token number">5878</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">14</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">14</span> -------  RX-packets: <span class="token number">5844</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ------- Forward Stats <span class="token keyword">for</span> RX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">15</span> -<span class="token operator">></span> TX <span class="token assign-left variable">Port</span><span class="token operator">=</span> <span class="token number">0</span>/Queue<span class="token operator">=</span><span class="token number">15</span> -------  RX-packets: <span class="token number">5930</span>           TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>  ---------------------- Forward statistics <span class="token keyword">for</span> port <span class="token number">0</span>  ----------------------  RX-packets: <span class="token number">94007</span>          RX-dropped: <span class="token number">0</span>             RX-total: <span class="token number">94007</span>  TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>             TX-total: <span class="token number">0</span>  ----------------------------------------------------------------------------  +++++++++++++++ Accumulated forward statistics <span class="token keyword">for</span> all ports+++++++++++++++  RX-packets: <span class="token number">94007</span>          RX-dropped: <span class="token number">0</span>             RX-total: <span class="token number">94007</span>  TX-packets: <span class="token number">0</span>              TX-dropped: <span class="token number">0</span>             TX-total: <span class="token number">0</span>  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到下发流表后，流量相对均匀的分布到了<code>0-15</code>这16个队列上。说明网卡的功能没有问题。</p><p>剩下来就是如何将这个规则下发以代码的形式集成到转发逻辑中了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">create_ipip_rss_flow</span><span class="token punctuation">(</span><span class="token class-name">dpdk_port_t</span> port_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// flow create 0 group 0 ingress pattern eth / ipv4 proto is 4 / ipv4 / end actions rss queues 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 end level 2 / end</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_flow_error</span> error<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_flow</span> <span class="token operator">*</span>flow<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rte_flow_attr</span> flow_attr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span>ingress <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">uint16_t</span> queue_list<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        queue_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_flow_item</span> patterns<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>type <span class="token operator">=</span> RTE_FLOW_ITEM_TYPE_ETH<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>type <span class="token operator">=</span> RTE_FLOW_ITEM_TYPE_IPV4<span class="token punctuation">,</span><span class="token punctuation">.</span>spec <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rte_flow_item_ipv4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token punctuation">.</span>hdr<span class="token punctuation">.</span>next_proto_id <span class="token operator">=</span> IPPROTO_IPIP<span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rte_flow_item_ipv4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token punctuation">.</span>hdr<span class="token punctuation">.</span>next_proto_id <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>type <span class="token operator">=</span> RTE_FLOW_ITEM_TYPE_IPV4<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>type <span class="token operator">=</span> RTE_FLOW_ITEM_TYPE_END<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">rte_flow_action</span> actions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>type <span class="token operator">=</span> RTE_FLOW_ACTION_TYPE_RSS<span class="token punctuation">,</span><span class="token punctuation">.</span>conf <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rte_flow_action_rss</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>queue_num <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">,</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue_list<span class="token punctuation">,</span><span class="token punctuation">.</span>level <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span>type <span class="token operator">=</span> RTE_FLOW_ACTION_TYPE_END<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    flow <span class="token operator">=</span> <span class="token function">rte_flow_create</span><span class="token punctuation">(</span>port_id<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flow_attr<span class="token punctuation">,</span> patterns<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flow<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">log_error</span><span class="token punctuation">(</span><span class="token string">"Failed to create ipip_rss_flow: %s"</span><span class="token punctuation">,</span> error<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际开发过程中，稍微调整了一下流表的规则，不再匹配<code>tcp/udp</code>协议，而是只匹配到ipv4层，这样就可以同时支持<code>TCP/UDP</code>了。</p><p>最后感谢一下<code>Github Copilot</code>和<code>Cursor</code>在代码研发中提供的巨大帮助！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近线上出现一些VM网卡收包队列不均匀的问题，即使是将网卡队列中断均匀的绑定到各个CPU上，依然会出现某个核特别高的情况：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;%Cpu0  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu1  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;97.5&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.8&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu2  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;99.1&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu3  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu4  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu5  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;97.4&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu6  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;97.4&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu7  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu8  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;46.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;3.4&lt;/span&gt; hi, &lt;span class=&quot;token number&quot;&gt;50.3&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu9  &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;97.4&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu10 &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu11 &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;99.1&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu12 &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu13 &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;99.1&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;0.9&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu14 &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st
%Cpu15 &lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; us,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; sy,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; ni, &lt;span class=&quot;token number&quot;&gt;98.3&lt;/span&gt; id,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; wa,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; hi,  &lt;span class=&quot;token number&quot;&gt;1.7&lt;/span&gt; si,  &lt;span class=&quot;token number&quot;&gt;0.0&lt;/span&gt; st&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;能看到其他核大部分还是比较均匀的，就是cpu8确实比其他核高很多。经过了一些排查，发现和VM使用了&lt;code&gt;IPIP Tunnel&lt;/code&gt;有关。&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://www.ichenfu.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="DPDK" scheme="https://www.ichenfu.com/tags/DPDK/"/>
    
    <category term="RSS" scheme="https://www.ichenfu.com/tags/RSS/"/>
    
    <category term="IPIP" scheme="https://www.ichenfu.com/tags/IPIP/"/>
    
    <category term="rte_flow" scheme="https://www.ichenfu.com/tags/rte-flow/"/>
    
  </entry>
  
  <entry>
    <title>在KVM虚拟机中开启TSC作为时钟源</title>
    <link href="https://www.ichenfu.com/2024/12/17/enable-tsc-virtualization-on-kvm/"/>
    <id>https://www.ichenfu.com/2024/12/17/enable-tsc-virtualization-on-kvm/</id>
    <published>2024-12-17T12:49:51.000Z</published>
    <updated>2024-12-17T10:59:34.701Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="/2024/11/11/facts-about-x86-tsc/">x86平台的TSC（TIME-STAMP COUNTER）</a>中大概分析了一下TSC的一些相关的特性，以及TSC作为系统时钟源的一些基础条件。那么，在虚拟化的场景下，如何让Guest也用上TSC呢？这篇文章就来讨论一下TSC在KVM虚拟化中的使用。</p><h2 id="基础分析"><a href="#基础分析" class="headerlink" title="基础分析"></a>基础分析</h2><p>默认情况下，KVM虚拟机首选的时钟源是<code>kvm-clock</code>，即使将VM的CPU Model设置为<code>host-passthrough</code>，也不会使用TSC作为时钟源。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># lscpu|grep Flags</span>Flags:                                fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq dtes64 vmx ssse3 fma cx16 pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves wbnoinvd arat vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq la57 rdpid fsrm md_clear flush_l1d arch_capabilities<span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/available_clocksource</span>kvm-clock acpi_pm<span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>kvm-clock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><p>可以看到，即使CPU有大部分TSC相关的Flags，但是<code>available_clocksource</code>里并没有TSC，current_clocksource也是kvm-clock，原因可以从dmesg里看到：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># dmesg |grep -i tsc</span><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> tsc: Detected <span class="token number">2199.998</span> MHz processor<span class="token punctuation">[</span>    <span class="token number">0.001000</span><span class="token punctuation">]</span> clocksource: tsc-early: mask: 0xffffffffffffffff max_cycles: 0x1fb63109b96, max_idle_ns: <span class="token number">440795265316</span> ns<span class="token punctuation">[</span>    <span class="token number">0.001000</span><span class="token punctuation">]</span> TSC deadline timer enabled<span class="token punctuation">[</span>    <span class="token number">0.577230</span><span class="token punctuation">]</span> clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x1fb63109b96, max_idle_ns: <span class="token number">440795265316</span> ns<span class="token punctuation">[</span>    <span class="token number">0.692265</span><span class="token punctuation">]</span> tsc: Marking TSC unstable due to TSC halts <span class="token keyword">in</span> idle states deeper than C2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在启动的时候，但是由于TSC在C2状态下会停止，所以被标记为不稳定。<br>当然，还有另外一种情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/available_clocksource</span>kvm-clock tsc acpi_pm<span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>kvm-clock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，虽然TSC是可用的，但是还是没有被优先使用。虽然有两种可能性，但其实根因都是一个，那就是在Guest里，CPU缺少一个关键特性，那就是上篇文章提到的<code>Invariant TSC</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cpuid -1 -l 0x80000007</span>CPU:   RAS Capability <span class="token punctuation">(</span>0x80000007/ebx<span class="token punctuation">)</span>:      MCA overflow recovery support <span class="token operator">=</span> <span class="token boolean">false</span>      SUCCOR support                <span class="token operator">=</span> <span class="token boolean">false</span>      HWA: hardware assert support  <span class="token operator">=</span> <span class="token boolean">false</span>      scalable MCA support          <span class="token operator">=</span> <span class="token boolean">false</span>   Advanced Power Management Features <span class="token punctuation">(</span>0x80000007/ecx<span class="token punctuation">)</span>:      CmpUnitPwrSampleTimeRatio <span class="token operator">=</span> 0x0 <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>   Advanced Power Management Features <span class="token punctuation">(</span>0x80000007/edx<span class="token punctuation">)</span>:      TS: temperature sensing diode           <span class="token operator">=</span> <span class="token boolean">false</span>      FID: frequency ID control               <span class="token operator">=</span> <span class="token boolean">false</span>      VID: voltage ID control                 <span class="token operator">=</span> <span class="token boolean">false</span>      TTP: thermal trip                       <span class="token operator">=</span> <span class="token boolean">false</span>      TM: thermal monitor                     <span class="token operator">=</span> <span class="token boolean">false</span>      STC: software thermal control           <span class="token operator">=</span> <span class="token boolean">false</span>      <span class="token number">100</span> MHz multiplier control              <span class="token operator">=</span> <span class="token boolean">false</span>      hardware P-State control                <span class="token operator">=</span> <span class="token boolean">false</span>      TscInvariant                            <span class="token operator">=</span> <span class="token boolean">false</span>      CPB: core performance boost             <span class="token operator">=</span> <span class="token boolean">false</span>      read-only effective frequency interface <span class="token operator">=</span> <span class="token boolean">false</span>      processor feedback interface            <span class="token operator">=</span> <span class="token boolean">false</span>      APM power reporting                     <span class="token operator">=</span> <span class="token boolean">false</span>      connected standby                       <span class="token operator">=</span> <span class="token boolean">false</span>      RAPL: running average power limit       <span class="token operator">=</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，关键的<code>TscInvariant</code>是false，在第一种情况下，<code>intel_idle</code>驱动正常加载，在<a href="https://github.com/torvalds/linux/blob/v6.12/drivers/idle/intel_idle.c#L2008">驱动代码中</a>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool __init <span class="token function">intel_idle_verify_cstate</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> mwait_hint<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> mwait_cstate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">MWAIT_HINT2CSTATE</span><span class="token punctuation">(</span>mwait_hint<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>MWAIT_CSTATE_MASK<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_substates <span class="token operator">=</span> <span class="token punctuation">(</span>mwait_substates <span class="token operator">>></span> mwait_cstate <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>MWAIT_SUBSTATE_MASK<span class="token punctuation">;</span><span class="token comment">/* Ignore the C-state if there are NO sub-states in CPUID for it. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>num_substates <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mwait_cstate <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">boot_cpu_has</span><span class="token punctuation">(</span>X86_FEATURE_NONSTOP_TSC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">mark_tsc_unstable</span><span class="token punctuation">(</span><span class="token string">"TSC halts in idle states deeper than C2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会检测CPU是否有<code>X86_FEATURE_NONSTOP_TSC</code>也就是<code>TscInvariant</code>，如果没有，就会标记TSC为不稳定。那么在这种情况下，因为TSC被标记为不稳定了，所以tsc是不会出现在available_clocksource中的。</p><p>那第二种情况呢，TSC没有被标记为不稳定，也出现在了<code>available_clocksource</code>中，但是为什么还是没有被优先使用呢？这是因为默认情况下，kvm-clock的优先级比TSC要高，可以看到在内核中的<a href="https://github.com/torvalds/linux/blob/v6.12/arch/x86/kernel/kvmclock.c">代码</a>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">clocksource</span> kvm_clock <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token string">"kvm-clock"</span><span class="token punctuation">,</span><span class="token punctuation">.</span>read<span class="token operator">=</span> kvm_clock_get_cycles<span class="token punctuation">,</span>    <span class="token comment">// 默认情况下，kvm-clock的rating是400，这比TSC的rating 300要高，所以当两者同时存在时，系统会优先使用kvm-clock作为时钟源</span><span class="token punctuation">.</span>rating<span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">,</span><span class="token punctuation">.</span>mask<span class="token operator">=</span> <span class="token function">CLOCKSOURCE_MASK</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span>flags<span class="token operator">=</span> CLOCK_SOURCE_IS_CONTINUOUS<span class="token punctuation">,</span><span class="token punctuation">.</span>id     <span class="token operator">=</span> CSID_X86_KVM_CLK<span class="token punctuation">,</span><span class="token punctuation">.</span>enable<span class="token operator">=</span> kvm_cs_enable<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在<code>kvm-clock</code>初始化的过程中，如果发现TSC满足条件的话，会主动降低自己的rating：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">kvmclock_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token comment">/* * X86_FEATURE_NONSTOP_TSC is TSC runs at constant rate * with P/T states and does not stop in deep C-states. * * Invariant TSC exposed by host means kvmclock is not necessary: * can use TSC as clocksource. * */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">boot_cpu_has</span><span class="token punctuation">(</span>X86_FEATURE_CONSTANT_TSC<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    <span class="token function">boot_cpu_has</span><span class="token punctuation">(</span>X86_FEATURE_NONSTOP_TSC<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    <span class="token operator">!</span><span class="token function">check_tsc_unstable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>kvm_clock<span class="token punctuation">.</span>rating <span class="token operator">=</span> <span class="token number">299</span><span class="token punctuation">;</span><span class="token function">clocksource_register_hz</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm_clock<span class="token punctuation">,</span> NSEC_PER_SEC<span class="token punctuation">)</span><span class="token punctuation">;</span>pv_info<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"KVM"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，只要CPU支持<code>TscInvariant</code>，那么kvm-clock的rating会主动降低自己的rating到299，那么在这种情况下，TSC将会成为rating更高的时钟源，从而被优先使用。但是由于Guest里CPU不支持<code>TscInvariant</code>，所以TSC并没有被优先使用。</p><p>到这里可以看出，要想让Guest支持并默认使用TSC作为时钟源，<code>TscInvariant</code>这个特性是十分关键的。</p><h2 id="开启TscInvariant特性"><a href="#开启TscInvariant特性" class="headerlink" title="开启TscInvariant特性"></a>开启TscInvariant特性</h2><p>Qemu最早在2.1版本中已经支持了<code>TscInvariant</code>，可以看到在这个版本的<a href="https://wiki.qemu.org/ChangeLog/2.1">Changelog</a>中：</p><blockquote><p>New “invtsc” (Invariant TSC) CPU feature. When enabled, this will block migration and savevm, so it is not enabled by default on any CPU model. To enable invtsc, the migratable&#x3D;no flag (supported only by -cpu host, by now) is required. So, invtsc is available only if using: -cpu host,migratable&#x3D;no,+invtsc.</p></blockquote><p>开启方法很简单，只需要在启动时加上参数<code>-cpu host,migratable=no,+invtsc</code>即可，或者等价的，在Libvirt的XML中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpu</span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>host-passthrough<span class="token punctuation">'</span></span> <span class="token attr-name">migratable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>feature</span> <span class="token attr-name">policy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>require<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>invtsc<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpu</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按文档启动一个虚拟机，然后查看对应的效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># lscpu |grep Fla</span>Flags:                              fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves wbnoinvd arat vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq la57 rdpid fsrm md_clear arch_capabilities<span class="token comment"># dmesg |grep tsc</span><span class="token punctuation">[</span>    <span class="token number">0.000005</span><span class="token punctuation">]</span> tsc: Detected <span class="token number">2199.998</span> MHz processor<span class="token punctuation">[</span>    <span class="token number">0.112544</span><span class="token punctuation">]</span> clocksource: tsc-early: mask: 0xffffffffffffffff max_cycles: 0x1fb63109b96, max_idle_ns: <span class="token number">440795265316</span> ns<span class="token punctuation">[</span>    <span class="token number">0.310799</span><span class="token punctuation">]</span> clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x1fb63109b96, max_idle_ns: <span class="token number">440795265316</span> ns<span class="token punctuation">[</span>    <span class="token number">0.310905</span><span class="token punctuation">]</span> clocksource: Switched to clocksource tsc<span class="token comment"># cpuid -1 -l 0x80000007|grep TscInvariant</span>      TscInvariant                            <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/available_clocksource</span>tsc kvm-clock acpi_pm<span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>tsc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，TSC已经成为可用并且是默认的时钟源了。</p><h2 id="VM热迁移"><a href="#VM热迁移" class="headerlink" title="VM热迁移"></a>VM热迁移</h2><p>现在我们已经实现了Guest默认使用TSC作为时钟源，但是还有一个问题，从上面的changelog里其实也能看出来，那就是现在的配置，VM是没有迁移能力的，当前的配置下，如果尝试迁移VM，会出现如下错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Requested operation is not valid: cannot migrate domain: State blocked by non-migratable CPU device <span class="token punctuation">(</span>invtsc flag<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么有了<code>TscInvariant</code>之后就无法迁移了呢？我们可以简单想象一下，一开始VM运行在Host1上，并且使用了TSC作为时钟源，那么VM里TSC的频率和Host1是一致的，这时如果VM被迁移到Host2上，并且Host2的TSC频率和Host1不一致的话，那此时VM读取到的TSC频率就会发生变化，这很显然并不是我们想要的结果。<br>但是，KVM是支持用户自定义VM的TSC频率的，如果我们手动设置一个TSC频率，让迁移前后，Guest看到的TSC频率保持一致，自然也就不会导致问题了，因此在Qemu 2.9版本中，也是支持了这种情况，当用户指定了TSC的频率，即使在有invtsc的情况下，依然可以支持热迁移，具体的修改可以参考<a href="https://github.com/qemu/qemu/commit/d99569d">这个commit</a>。而我们需要做的，就是在启动参数里加上<code>-cpu host,migratable=on,+invtsc,tsc-freq=XXX</code>，或者等价的，使用libvirt xml：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpu</span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>host-passthrough<span class="token punctuation">'</span></span> <span class="token attr-name">migratable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>on<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>feature</span> <span class="token attr-name">policy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>require<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>invtsc<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpu</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clock</span> <span class="token attr-name">offset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>utc<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timer</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>tsc<span class="token punctuation">'</span></span> <span class="token attr-name">frequency</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>2200000000<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clock</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TSC虚拟化的硬件加速"><a href="#TSC虚拟化的硬件加速" class="headerlink" title="TSC虚拟化的硬件加速"></a>TSC虚拟化的硬件加速</h2><p>还剩下最后的一个问题，KVM是如何高效的实现固定Guest TSC频率的？当Guest TSC频率和Host TSC频率不一致时，这中间又是如何转换的？以及如何在迁移过程中确保TSC不会发生跳变？<br>在这种场景下，CPU支持的<code>TSC scaling</code>以及<code>TSC offseting</code>这两个特性就十分重要了，怎么理解呢，如果启用了<code>TSC offseting</code>，那么Guest在读取TSC的时候，硬件会在原始TSC值的基础上，加上一个设置的offset，这样在迁移过程中，源和目的宿主机的TSC base值不一样的情况下，只需要改一下这个offset值就好了，由于这个offset也只会在Guest读取时加上，因此也不会影响宿主机使用TSC。<br><code>TSC scaling</code>也是类似的机制，通过设置一个频率倍率，让Guest读取TSC时将CPU当前的TSC值乘以这个倍率之后返回给Geust，从而解决用户设置的TSC频率和CPU本身TSC频率不一致的问题。<br>具体的信息，可以参考一下Intel的<a href="https://cdrdv2.intel.com/v1/dl/getContent/671506">开发手册</a>：</p><blockquote><h4 id="26-6-5-Time-Stamp-Counter-Offset-and-Multiplier"><a href="#26-6-5-Time-Stamp-Counter-Offset-and-Multiplier" class="headerlink" title="26.6.5 Time-Stamp Counter Offset and Multiplier"></a>26.6.5 Time-Stamp Counter Offset and Multiplier</h4><p> The VM-execution control fields include a 64-bit TSC-offset field. If the “RDTSC exiting” control is 0 and the “use TSC offsetting” control is 1, this field controls executions of the RDTSC and RDTSCP instructions. It also controls executions of the RDMSR instruction that read from the IA32_TIME_STAMP_COUNTER MSR. For all of these, the value of the TSC offset is added to the value of the time-stamp counter, and the sum is returned to guest software in EDX:EAX.</p><p> Processors that support the 1-setting of the “use TSC scaling” control also support a 64-bit TSC-multiplier field. If this control is 1 (and the “RDTSC exiting” control is 0 and the “use TSC offsetting” control is 1), this field also affects the executions of the RDTSC, RDTSCP, and RDMSR instructions identified above. Specifically, the contents of the time-stamp counter is first multiplied by the TSC multiplier before adding the TSC offset.</p><p> See Chapter 26 for a detailed treatment of the behavior of RDTSC, RDTSCP, and RDMSR in VMX non-root operation.</p><h3 id="27-3-CHANGES-TO-INSTRUCTION-BEHAVIOR-IN-VMX-NON-ROOT-OPERATION"><a href="#27-3-CHANGES-TO-INSTRUCTION-BEHAVIOR-IN-VMX-NON-ROOT-OPERATION" class="headerlink" title="27.3 CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION"></a>27.3 CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION</h3><ul><li><p><strong>RDTSC</strong>. Behavior of the RDTSC instruction is determined by the settings of the “RDTSC exiting” and “use TSC offsetting” VM-execution controls:<br>  - If both controls are 0, RDTSC operates normally.</p><p>  - If the “RDTSC exiting” VM-execution control is 0 and the “use TSC offsetting” VM-execution control is 1, the value returned is determined by the setting of the “use TSC scaling” VM-execution control:</p><ul><li>If the control is 0, RDTSC loads EAX:EDX with the sum of the value of the IA32_TIME_STAMP_COUNTER MSR and the value of the TSC offset.</li><li>If the control is 1, RDTSC first computes the product of the value of the IA32_TIME_STAMP_COUNTER MSR and the value of the TSC multiplier. It then shifts the value of the product right 48 bits and loads EAX:EDX with the sum of that shifted value and the value of the TSC offset.</li></ul><p>  - If the “RDTSC exiting” VM-execution control is 1, RDTSC causes a VM exit.</p></li></ul></blockquote><p>可以看到在Intel平台，<code>TSC-offset</code>以及<code>TSC multiplier</code>是VMCS中的两个字段，通过修改这两个以及<code>RDTSC exiting</code>字段，可以很好的控制Guest中TSC的行为。</p><p>当然，AMD的实现和Intel还有一些区别，具体的也可以参考<a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/40332.pdf">AMD的文档</a></p><blockquote><h3 id="15-30-5-TSC-Ratio-MSR-C000-0104h"><a href="#15-30-5-TSC-Ratio-MSR-C000-0104h" class="headerlink" title="15.30.5 TSC Ratio MSR (C000_0104h)"></a>15.30.5 TSC Ratio MSR (C000_0104h)</h3><p>Writing to the TSC Ratio MSR allows the hypervisor to control the guest’s view of the Time Stamp Counter. The contents of TSC Ratio MSR sets the value of the TSCRatio. This constant scales the timestamp value returned when the TSC is read by a guest via the RDTSC or RDTSCP instructions or when the TSC, MPERF, or MPerfReadOnly MSRs are read via the RDMSR instruction by a guest running under virtualization.</p><p>This facility allows the hypervisor to provide a consistent TSC, MPERF, and MPerfReadOnly rate for a guest process when moving that process between cores that have a differing P0 rate. The TSCRatio does not affect the value read from the TSC, MPERF, and MPerfReadOnly MSRs when in host mode or when virtualization is disabled. System Management Mode (SMM) code sees unscaled TSC, MPERF and MPerfReadOnly values unless the SMM code is executed within a guest container. The TSCRatio value does not affect the rate of the underlying TSC, MPERF, and MPerfReadOnly counters, nor the value that gets written to the TSC, MPERF, and MPerfReadOnly MSRs counters on a write by either the host or the guest.</p><p>The TSC Ratio MSR specifies the TSCRatio value as a fixed-point binary number in 8.32 format, which is composed of 8 bits of integer and 32 bits of fraction. This number is the ratio of the desired P0 frequency to be presented to the guest relative to the P0 frequency of the core (See Section 17.1, “PState Control,” on page 657). The reset value of the TSCRatio is 1.0, which sets the guest P0 frequency to match the core P0 frequency.</p><p>Note that:<br>        <code>TSCFreq = Core P0 frequency * TSCRatio, so TSCRatio = (Desired TSCFreq) / Core P0 frequency.</code></p><p>The TSC value read by the guest is computed using the TSC Ratio MSR along with the TSC_OFFSET field from the VMCB so that the actual value returned is:<br>        <code>TSC Value (in guest) = (P0 frequency * TSCRatio * t) + VMCB.TSC_OFFSET + (Last Value Written to TSC) * TSCRatio</code><br>            Where t is time since the TSC was last written via the TSC MSR (or since reset if not written)</p></blockquote><p>和Intel相比，AMD的TSC offset值是设置在VMCB中的，而TSC Scaling的倍率是基于MSR来实现的。实现的逻辑有区别并不重要，毕竟KVM会隔离掉不同平台的实现细节。重要的是，软硬件的协同配合，使得在虚拟化场景下，TSC可以作为一个高效的时钟源被VM使用。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>最后来看看相比于<code>kvm-clock</code>时钟源，使用<code>tsc</code>作为时钟源能够带来多大的性能提升吧。从红帽找到了一个测试时钟性能的<a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux_for_real_time/7/html/reference_guide/sect-posix_clocks">例子</a>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> rc<span class="token punctuation">;</span><span class="token keyword">long</span> i<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timespec</span> ts<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">500000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>rc <span class="token operator">=</span> <span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ts<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>tsc<span class="token comment"># time taskset -c 6 ./clock_timing</span>real    0m10.858suser    0m10.821ssys     0m0.000s<span class="token comment"># echo kvm-clock |sudo tee /sys/devices/system/clocksource/clocksource0/current_clocksource</span>kvm-clock<span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>kvm-clock<span class="token comment"># time taskset -c 6 ./clock_timing</span>real    0m13.530suser    0m13.482ssys     0m0.002s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样是获取<code>500000000</code>次时间，<code>tsc</code>需要<code>10.821s</code>，而<code>kvm-clock</code>需要<code>13.482s</code>，差不多提升了20%，算是相当大的提升幅度了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;/2024/11/11/facts-about-x86-tsc/&quot;&gt;x86平台的TSC（TIME-STAMP COUNTER）&lt;/a&gt;中大概分析了一下TSC的一些相关的特性，以及TSC作为系统时钟源的一些基础条件。那么，在虚拟化的场景下，如何让Guest也用上TSC呢？这篇文章就来讨论一下TSC在KVM虚拟化中的使用。&lt;/p&gt;
&lt;h2 id=&quot;基础分析&quot;&gt;&lt;a href=&quot;#基础分析&quot; class=&quot;headerlink&quot; title=&quot;基础分析&quot;&gt;&lt;/a&gt;基础分析&lt;/h2&gt;&lt;p&gt;默认情况下，KVM虚拟机首选的时钟源是&lt;code&gt;kvm-clock&lt;/code&gt;，即使将VM的CPU Model设置为&lt;code&gt;host-passthrough&lt;/code&gt;，也不会使用TSC作为时钟源。&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# lscpu|grep Flags&lt;/span&gt;
Flags:                                fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq dtes64 vmx ssse3 fma cx16 pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves wbnoinvd arat vnmi avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq la57 rdpid fsrm md_clear flush_l1d arch_capabilities
&lt;span class=&quot;token comment&quot;&gt;# cat /sys/devices/system/clocksource/clocksource0/available_clocksource&lt;/span&gt;
kvm-clock acpi_pm
&lt;span class=&quot;token comment&quot;&gt;# cat /sys/devices/system/clocksource/clocksource0/current_clocksource&lt;/span&gt;
kvm-clock&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://www.ichenfu.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="TSC Virtualization" scheme="https://www.ichenfu.com/tags/TSC-Virtualization/"/>
    
    <category term="TSC直通" scheme="https://www.ichenfu.com/tags/TSC%E7%9B%B4%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>x86平台的TSC（TIME-STAMP COUNTER）</title>
    <link href="https://www.ichenfu.com/2024/11/11/facts-about-x86-tsc/"/>
    <id>https://www.ichenfu.com/2024/11/11/facts-about-x86-tsc/</id>
    <published>2024-11-11T12:30:42.000Z</published>
    <updated>2024-11-22T01:59:30.314Z</updated>
    
    <content type="html"><![CDATA[<p>今天跟着Intel的开发手册，看看如何随着Intel对TSC不断的修改和增加新特性，让TSC从一个简单的性能计数器发展成当前Linux上x86平台最重要的时钟源之一。本文基本上可以看作是<a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3b-part-2-manual.pdf">Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2</a>中<code>17.15 TIME-STAMP COUNTER</code>这章的翻译和总结。</p><p>在x86平台上，Linux系统里最常用的一个时钟源就是<code>tsc</code>，具体的，可以通过命令查看当前的时钟源和系统里可用的时钟源：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/available_clocksource</span>tsc hpet acpi_pm<span class="token comment"># cat /sys/devices/system/clocksource/clocksource0/current_clocksource</span>tsc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么TSC是个什么东西呢？我们可以跟着手册看一看。</p><span id="more"></span><h2 id="TIME-STAMP-COUNTER"><a href="#TIME-STAMP-COUNTER" class="headerlink" title="TIME-STAMP COUNTER"></a>TIME-STAMP COUNTER</h2><p>从 Pentium 处理器开始，Intel 64 和 IA-32 架构定义了一种时间戳计数器机制（TSC），可以用于监控和识别处理器事件的相对时间。TSC包括以下组件：</p><pre><code>- TSC flag：用于标识TSC是否可用，当`CPUID.1:EDX.TSC[bit 4] = 1`时，TSC可用- IA32_TIME_STAMP_COUNTER MSR：对应TSC值的寄存器- RDTSC指令：读取TSC寄存器值的指令- TSD flag： 用于开关TSC功能，`CR4.TSD[bit 2] = 1`时开启TSC</code></pre><p>TSC从第一次在CPU中实现到如今很多年了，所以不同CPU上的一些表现还是有些区别的，但主要的特点是通用的，首先TSC是一个64bit大小的计数器，当CPU重置时，这个计数器也会被重置成0，重置后，即使CPU因为执行了HLT指令进入idle状态，这个寄存器也会持续的增加。</p><p>但是TSC会按什么样的频率增加呢？这里不同的CPU差异就比较大了。在一些比较老的CPU上（大概是07-08年之前），TSC是跟着CPU的运行频率增加的，比如当前CPU跑在2.4GHz，那TSC就每秒增加24000000，但是针对这些老的CPU，超频、以及CPU自身的睿频都会对TSC的计数产生影响。这其实对用户是不太友好的，毕竟睿频是硬件层面的，这个计数器就不那么“稳定”了。</p><p>所以后续的新CPU，Intel将这个行为修改成了以固定频率增加，只是这个频率具体是多少得看具体的配置，具体的TSC频率如何检测，手册里有专门的一章进行解释，这里我们不过多涉及。</p><p>在新CPU里，TSC以固定频率增长，所以这其实是一个TSC的特性，叫做<code>Constant TSC</code>，有了这个特性之后，TSC频率相对就稳定了，不会随着CPU睿频而随意改变频率，所以他也就可以成为一个稳定的时钟源了。因此这个特性会一直在后续的CPU中提供。</p><p>用户可以使用<code>RDTSC</code>这个CPU指令获取TSC的值，正常情况下（计数器没有溢出），Intel的CPU可以保证每次通过<code>RDTSC</code>读取的值都是单调递增的，同时可以保证在10年内计数器不会溢出。但是需要注意的是，这个指令它不是有序的（也就说他是有可能被CPU乱序执行的，所以可能需要加上memory barrier）。另外由于TSC是一个MSR，所以其实这个寄存器是可以通过<code>RDMSR</code>和<code>WRMSR</code>指令进行读写的，只是一些老CPU上只能写低32位（高32位此时会清0）。</p><h3 id="Invariant-TSC"><a href="#Invariant-TSC" class="headerlink" title="Invariant TSC"></a>Invariant TSC</h3><p>前面提到TSC即使CPU处在halt状态，依然会持续的累加，但即使是这样，TSC依然不是100%可依赖最为一个时钟源的，为什么呢？因为halt状态只是CPU的C1状态，现代的CPU为了省电，引入了更多更深的C states，具体可以参考之前关于电源管理的内容<a href="/2020/07/17/cpu-idle-time-managment/">再谈CPU的电源管理（如何做到稳定全核睿频？）</a>，当CPU进入到比较深的C states，比如C6，此时整个CPU的Core基本都被关闭了，那TSC自然也有可能不工作了。</p><p>为了解决这个问题呢，Intel又引入了一个新的特性增强，叫<code>Invariant TSC</code>，这个特性可以当<code>CPUID.80000007H:EDX[8] == 1</code>时，代表CPU支持这个特性。有这个特性的CPU，在任何的C states下，TSC都会持续运行，在Linux里，这个特性也会被称为<code>NONSTOP_TSC</code>（感觉这个更传神一些，不停止的TSC）。</p><p>可以看到引入<code>Constant TSC</code>和<code>Invariant TSC</code>之后，CPU先后解决了P-States(CPU频率变化)和C-States(CPU电源状态)对TSC频率的影响，逐渐将TSC设计成符合时钟源要求的样子，这也算是软硬件协同发展，螺旋上升的正面例子吧。</p><h3 id="IA32-TSC-AUX-Register-and-RDTSCP-Support"><a href="#IA32-TSC-AUX-Register-and-RDTSCP-Support" class="headerlink" title="IA32_TSC_AUX Register and RDTSCP Support"></a>IA32_TSC_AUX Register and RDTSCP Support</h3><p>看起来到这里已经万事大吉了？其实并没有，前面提到，<code>RDTSC</code>指令并不是有序的，意味着CPU硬件有可能对这个执行乱序执行，这可能并不是软件所预期的结果，举个例子，假如想通过基于类似<code>RDTSC;other insturctions;RDTSC</code>这样的指令顺序来计算<code>other insturctions</code>消耗的时间，在真正执行的时候，有可能就按<code>RDTSC;RDTSCother insturctions</code>的顺序了，这显然不是所期望的结果。</p><p>所以Intel针对这个问题，又增加了一个新的指令<code>RDTSCP</code>，使得可以原子地读取TSC。当执行<code>RDTSCP</code>指令时，会同时读取TSC和IA32_TSC_AUX两个寄存器的值。并且这个操作是原子的，不会出现上下文切换的问题。不过需要注意的是，只有当<code>CPUID.80000001H:EDX[27] == 1</code>时，CPU才支持<code>RDTSCP</code>指令。</p><p>针对这个乱序的问题，其实Linux内核里也是做了相应的处理的，我们可以从内核读取TSC的源码看出来，源码里的注释也是非常的详细：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">rdtsc_ordered</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">DECLARE_ARGS</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* * The RDTSC instruction is not ordered relative to memory * access.  The Intel SDM and the AMD APM are both vague on this * point, but empirically an RDTSC instruction can be * speculatively executed before prior loads.  An RDTSC * immediately after an appropriate barrier appears to be * ordered as a normal load, that is, it provides the same * ordering guarantees as reading from a global memory location * that some other imaginary CPU is updating continuously with a * time stamp. * * Thus, use the preferred barrier on the respective CPU, aiming for * RDTSCP as the default. */</span>     <span class="token comment">//优先使用rdtscp，如果不支持，先执行lfence再执行rdtsc</span><span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token function">ALTERNATIVE_2</span><span class="token punctuation">(</span><span class="token string">"rdtsc"</span><span class="token punctuation">,</span>   <span class="token string">"lfence; rdtsc"</span><span class="token punctuation">,</span> X86_FEATURE_LFENCE_RDTSC<span class="token punctuation">,</span>   <span class="token string">"rdtscp"</span><span class="token punctuation">,</span> X86_FEATURE_RDTSCP<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">EAX_EDX_RET</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token comment">/* RDTSCP clobbers ECX with MSR_TSC_AUX. */</span><span class="token operator">::</span> <span class="token string">"ecx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">EAX_EDX_VAL</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Time-Stamp-Counter-Adjustment"><a href="#Time-Stamp-Counter-Adjustment" class="headerlink" title="Time-Stamp Counter Adjustment"></a>Time-Stamp Counter Adjustment</h3><p>最后的最后，还有一个问题需要解决，上面其实也提到了，TSC本质上是个MSR（IA32_TIME_STAMP_COUNTER MSR 地址10H），而这个MSR是可写的！这会存在一个问题，对于现代的多核系统，每个核都有自己的TSC MSR，如果某个核的MSR被修改了，这个修改怎么同步到其他核上去呢？很显然，不管是想计算出来被修改的核心的TSC的变化值，以及将这个值同步到其他的核上，都是不现实的。因为没办法在同一时刻在所有核上执行相同的指令。</p><p>但是多核之间同步TSC需求又是客观存在的，怎么办呢？Intel提供了一个新的MSR：<code>IA32_TSC_ADJUST(地址3BH)</code>来解决这个问题。首先和TSC一样每个核都有自己独立的<code>IA32_TSC_ADJUST</code>，当处理器重置时，<code>IA32_TSC_ADJUST</code>也会被置为0，当对<code>IA32_TIME_STAMP_COUNTER</code>进行写入时，比如加上（或者）一个X的值，那么对应核的<code>IA32_TSC_ADJUST</code>也会有对应的X值被加上（或者减去）。因此有了这个MSR之后，想计算某个核TSC的变化值，直接读取<code>IA32_TSC_ADJUST</code>里的值就行了，如果要把这个值同步到其他的核，就只需要把这个值写入到其他核的<code>IA32_TSC_ADJUST</code>里就行了。这就直接解决了多核之间TSC同步的问题，不过这个特性也不是所有CPU都支持，只有当<code>CPUID.(EAX=07H, ECX=0H):EBX.TSC_ADJUST == 1</code>时才支持。</p><p>到这里，TSC就变得真正可依赖了，首先有了<code>Constant TSC</code>，确保TSC按固定频率运行，然后有了<code>Invariant TSC</code>确保TSC一直运行，还有<code>IA32_TSC_ADJUST</code>确保当TSC被修改后依然能被同步回来。有了这些特性，TSC就可以成为系统中可信赖的时钟源。我们也可以通过Linux内核里的代码，看看内核是如何针对这种场景进行适配的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> __init <span class="token function">check_system_tsc_reliable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span><span class="token comment">/* * Disable the clocksource watchdog when the system has: *  - TSC running at constant frequency *  - TSC which does not stop in C-States *  - the TSC_ADJUST register which allows to detect even minimal *    modifications *  - not more than two sockets. As the number of sockets cannot be *    evaluated at the early boot stage where this has to be *    invoked, check the number of online memory nodes as a *    fallback solution which is an reasonable estimate. */</span>    <span class="token comment">// 默认情况下Kernel假设TSC不稳定，所以会有个watchdog进行检测，当满足下面几个条件时，TSC足够稳定，watchdog也不需要运行了。</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">boot_cpu_has</span><span class="token punctuation">(</span>X86_FEATURE_CONSTANT_TSC<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    <span class="token function">boot_cpu_has</span><span class="token punctuation">(</span>X86_FEATURE_NONSTOP_TSC<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    <span class="token function">boot_cpu_has</span><span class="token punctuation">(</span>X86_FEATURE_TSC_ADJUST<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    nr_online_nodes <span class="token operator">&lt;=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token function">tsc_disable_clocksource_watchdog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，跟着文档的节奏，其实也可以看到TSC的发展历程，硬件不断的做出一些变化从而满足软件层面的需求，确定经历了相当长的时间。其实除此之外，TSC还有一些其他相关的特性，主要是和虚拟化相关，也是硬件为了更好的实现虚拟化做出的适配，这里就暂时不说了，期望下次可以继续聊聊虚拟化场景下TSC的一些特性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天跟着Intel的开发手册，看看如何随着Intel对TSC不断的修改和增加新特性，让TSC从一个简单的性能计数器发展成当前Linux上x86平台最重要的时钟源之一。本文基本上可以看作是&lt;a href=&quot;https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3b-part-2-manual.pdf&quot;&gt;Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3B: System Programming Guide, Part 2&lt;/a&gt;中&lt;code&gt;17.15 TIME-STAMP COUNTER&lt;/code&gt;这章的翻译和总结。&lt;/p&gt;
&lt;p&gt;在x86平台上，Linux系统里最常用的一个时钟源就是&lt;code&gt;tsc&lt;/code&gt;，具体的，可以通过命令查看当前的时钟源和系统里可用的时钟源：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# cat /sys/devices/system/clocksource/clocksource0/available_clocksource&lt;/span&gt;
tsc hpet acpi_pm
&lt;span class=&quot;token comment&quot;&gt;# cat /sys/devices/system/clocksource/clocksource0/current_clocksource&lt;/span&gt;
tsc&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么TSC是个什么东西呢？我们可以跟着手册看一看。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux Kernel" scheme="https://www.ichenfu.com/categories/Linux-Kernel/"/>
    
    
    <category term="x86_64" scheme="https://www.ichenfu.com/tags/x86-64/"/>
    
    <category term="TSC" scheme="https://www.ichenfu.com/tags/TSC/"/>
    
    <category term="时钟源" scheme="https://www.ichenfu.com/tags/%E6%97%B6%E9%92%9F%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>一个UFO引发的惨案</title>
    <link href="https://www.ichenfu.com/2024/04/01/ufo-feature-caused-network-failure/"/>
    <id>https://www.ichenfu.com/2024/04/01/ufo-feature-caused-network-failure/</id>
    <published>2024-04-01T12:30:57.000Z</published>
    <updated>2024-04-01T10:45:31.560Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要解释一下标题，原谅我当了一回标题党，此UFO不是<code>Unidentified flying object</code>，而是在网络中的一个Oflload卸载技术<code>UDP fragmentation offload</code>。事情的起因是这样的，我们最近尝试将线上的虚拟机，从基于网卡SR-IOV+直通的方案，切换到基于DPDK+vhost-user的方案，以换取热迁移的效率提升。</p><p>从之前的模拟压测和线上灰度效果来看，新的DPDK方案的性能和稳定性都处于很好的水平，在我们的场景下可以很好地满足需求。<br>直到灰度到某个业务的时候，发生了一些问题，导致了虚拟机的网络中断。<span id="more"></span></p><p>我们通过热拔插方式进行网络切换，首先，会把当前直通的网卡从虚拟机中热拔出来，然后，再把一个vhost-user网卡热插到虚拟机中，从而实现网卡的切换。在切换过程中，大致会有3-5s左右的网络中断，但根据和业务的沟通，在单线程的操作情况下，这样的中断是没有问题的，不会影响业务。</p><p>为了保证业务的稳定，我们在网卡切换后，会持续ping 10s对应的虚拟机，确保网络正常后才会进行下一台的操作。</p><p>然后问题就发生了，在某些虚拟机切换网卡之后，大约5分钟内，网络是正常的，但是超过5分钟之后，突然网络就不通了，这个问题也是随机的，而对于网络不通的机器，通过重启DPDK进程的方式，网络又可以恢复几分钟，然后继续不通。这些现象确实在之前的测试中没有遇到过。从日志看，有少量的DPDK进程打印了这两条日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">VHOST_DATA: <span class="token punctuation">(</span>/tmp/ens8f0-2.sock<span class="token punctuation">)</span> failed to allocate memory <span class="token keyword">for</span> mbuf.VHOST_DATA: <span class="token punctuation">(</span>/tmp/ens8f0-2.sock<span class="token punctuation">)</span> failed to copy desc to mbuf.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从日志看，应该是给DPDK分配的内存不够了，导致DPDK从内存池里分配mbuf时无内存可用，但是DPDK使用的内存，是经过精确计算的呀？看看内存分配数量相关的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_IP_MTU</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">L2_OVERHEAD</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token number">14</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VF_RX_OFFSET</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_MBUF_SIZE</span> <span class="token expression"><span class="token punctuation">(</span>DEFAULT_IP_MTU <span class="token operator">+</span> L2_OVERHEAD <span class="token operator">+</span> RTE_PKTMBUF_HEADROOM <span class="token operator">+</span> VF_RX_OFFSET<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_VHOST_QUEUE_PAIRS</span> <span class="token expression"><span class="token number">16</span></span></span><span class="token comment">/* rxq/txq descriptors numbers */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RXQ_TXQ_DESC_1K</span> <span class="token expression"><span class="token number">1024</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RXQ_TXQ_DESC_8K</span> <span class="token expression"><span class="token number">8192</span></span></span><span class="token comment">/* relay mempool config */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_NR_RX_QUEUE</span> <span class="token expression">MAX_VHOST_QUEUE_PAIRS</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_NR_TX_QUEUE</span> <span class="token expression">MAX_VHOST_QUEUE_PAIRS</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_NR_RX_DESC</span><span class="token expression">RXQ_TXQ_DESC_8K</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT_NR_TX_DESC</span><span class="token expression">RXQ_TXQ_DESC_1K</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_PKTMBUF_POOL</span><span class="token expression"><span class="token punctuation">(</span>DEFAULT_NR_RX_DESC <span class="token operator">*</span> DEFAULT_NR_RX_QUEUE <span class="token operator">+</span> DEFAULT_NR_TX_DESC <span class="token operator">*</span> DEFAULT_NR_TX_QUEUE <span class="token operator">+</span> <span class="token number">4096</span><span class="token punctuation">)</span></span></span><span class="token comment">// ...</span>mpool <span class="token operator">=</span> <span class="token function">rte_pktmbuf_pool_create</span><span class="token punctuation">(</span>mp_name<span class="token punctuation">,</span> n_mbufs<span class="token punctuation">,</span> RTE_MEMPOOL_CACHE_MAX_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> DEFAULT_MBUF_SIZE<span class="token punctuation">,</span> request_socket_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们给每个VM分配了最多16个队列，MTU为1500，网卡侧同样支持16个发送队列+16个接收队列，其中每个接收队列设置ring buffer大小为8192，发送队列ring buffer大小1024，经过一系列的计算<code>NUM_PKTMBUF_POOL</code>这个值应该在所有场景都能满足需求，那为什么会出现内存不够的情况呢？我们再深入看一下DPDK相关的代码：</p><p>首先这个日志，在DPDK中有两个地方会打印，一个是在<code>virtio_dev_tx_split</code>函数中，另一个函数是<code>vhost_dequeue_single_packed</code>，这俩函数的功能是一致的，只是一个是用来处理老的<code>virtio split ring</code>的场景，另一个是处理<code>packed ring</code>的场景，而我们目前用的还是老的<code>split ring</code>，于是着重看下相关的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__rte_always_inline<span class="token keyword">static</span> <span class="token class-name">uint16_t</span><span class="token function">virtio_dev_tx_split</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_net</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vhost_virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">rte_mempool</span> <span class="token operator">*</span>mbuf_pool<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rte_mbuf</span> <span class="token operator">*</span><span class="token operator">*</span>pkts<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> count<span class="token punctuation">,</span>bool legacy_ol_flags<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ...省略</span>    <span class="token comment">// 一次循环，最多取32个数据</span>count <span class="token operator">=</span> <span class="token function">RTE_MIN</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> MAX_PKT_BURST<span class="token punctuation">)</span><span class="token punctuation">;</span>count <span class="token operator">=</span> <span class="token function">RTE_MIN</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> avail_entries<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">VHOST_LOG_DATA</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>ifname<span class="token punctuation">,</span> DEBUG<span class="token punctuation">,</span> <span class="token string">"about to dequeue %u buffers\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rte_pktmbuf_alloc_bulk</span><span class="token punctuation">(</span>mbuf_pool<span class="token punctuation">,</span> pkts<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...省略</span>        <span class="token comment">// 拷贝Guest中的网络包到pkts(rte_mbuf)中</span>err <span class="token operator">=</span> <span class="token function">desc_to_mbuf</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> vq<span class="token punctuation">,</span> buf_vec<span class="token punctuation">,</span> nr_vec<span class="token punctuation">,</span> pkts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>   mbuf_pool<span class="token punctuation">,</span> legacy_ol_flags<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>allocerr_warned<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 拷贝失败了，打印了第二条日志，第一条日志在desc_to_mbuf打印了</span><span class="token function">VHOST_LOG_DATA</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>ifname<span class="token punctuation">,</span> ERR<span class="token punctuation">,</span> <span class="token string">"failed to copy desc to mbuf.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>allocerr_warned <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>dropped <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// ...省略</span><span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> dropped<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> __rte_always_inline <span class="token keyword">int</span><span class="token function">desc_to_mbuf</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">virtio_net</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vhost_virtqueue</span> <span class="token operator">*</span>vq<span class="token punctuation">,</span>  <span class="token keyword">struct</span> <span class="token class-name">buf_vector</span> <span class="token operator">*</span>buf_vec<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> nr_vec<span class="token punctuation">,</span>  <span class="token keyword">struct</span> <span class="token class-name">rte_mbuf</span> <span class="token operator">*</span>m<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rte_mempool</span> <span class="token operator">*</span>mbuf_pool<span class="token punctuation">,</span>  bool legacy_ol_flags<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> slot_idx<span class="token punctuation">,</span> bool is_async<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ...省略</span>buf_addr <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_addr<span class="token punctuation">;</span>buf_iova <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_iova<span class="token punctuation">;</span>buf_len <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_len<span class="token punctuation">;</span>buf_offset <span class="token operator">=</span> hdr_remain<span class="token punctuation">;</span>buf_avail <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_len <span class="token operator">-</span> hdr_remain<span class="token punctuation">;</span><span class="token function">PRINT_PACKET</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buf_addr <span class="token operator">+</span> buf_offset<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>buf_avail<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mbuf_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>mbuf_avail  <span class="token operator">=</span> m<span class="token operator">-></span>buf_len <span class="token operator">-</span> RTE_PKTMBUF_HEADROOM<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>is_async<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pkts_info <span class="token operator">=</span> async<span class="token operator">-></span>pkts_info<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">async_iter_initialize</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> async<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// buf_avail是Guest中网络包的剩余长度，mbuf_avail是当前mbuf中剩余的容量</span>        <span class="token comment">// 本次拷贝数据量是这两者的小值</span>cpy_len <span class="token operator">=</span> <span class="token function">RTE_MIN</span><span class="token punctuation">(</span>buf_avail<span class="token punctuation">,</span> mbuf_avail<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 拷贝数据</span><span class="token keyword">if</span> <span class="token punctuation">(</span>is_async<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">async_fill_seg</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> vq<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> mbuf_offset<span class="token punctuation">,</span>   buf_iova <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> cpy_len<span class="token punctuation">,</span> false<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">goto</span> error<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>hdr <span class="token operator">&amp;&amp;</span> cur <span class="token operator">==</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">rte_memcpy</span><span class="token punctuation">(</span><span class="token function">rte_pktmbuf_mtod_offset</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> mbuf_offset<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buf_addr <span class="token operator">+</span> buf_offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cpy_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">sync_fill_seg</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> vq<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> mbuf_offset<span class="token punctuation">,</span>      buf_addr <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span>      buf_iova <span class="token operator">+</span> buf_offset<span class="token punctuation">,</span> cpy_len<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 计算拷贝后的结果</span>mbuf_avail  <span class="token operator">-=</span> cpy_len<span class="token punctuation">;</span>mbuf_offset <span class="token operator">+=</span> cpy_len<span class="token punctuation">;</span>buf_avail <span class="token operator">-=</span> cpy_len<span class="token punctuation">;</span>buf_offset <span class="token operator">+=</span> cpy_len<span class="token punctuation">;</span><span class="token comment">/* This buf reaches to its end, get the next one */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buf_avail <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果Guest里的数据都拷贝完了，直接break循环</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>vec_idx <span class="token operator">>=</span> nr_vec<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span>buf_addr <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_addr<span class="token punctuation">;</span>buf_iova <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_iova<span class="token punctuation">;</span>buf_len <span class="token operator">=</span> buf_vec<span class="token punctuation">[</span>vec_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>buf_len<span class="token punctuation">;</span>buf_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>buf_avail  <span class="token operator">=</span> buf_len<span class="token punctuation">;</span><span class="token function">PRINT_PACKET</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>buf_addr<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>buf_avail<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* * This mbuf reaches to its end, get a new one * to hold more data. */</span>        <span class="token comment">// 拷贝未结束，但是mbuf空间用完了，需要重新申请一个新的mbuf</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mbuf_avail <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur <span class="token operator">=</span> <span class="token function">rte_pktmbuf_alloc</span><span class="token punctuation">(</span>mbuf_pool<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 申请新的mbuf失败了，打印第一条日志，跳到error退出</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">VHOST_LOG_DATA</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>ifname<span class="token punctuation">,</span> ERR<span class="token punctuation">,</span><span class="token string">"failed to allocate memory for mbuf.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">goto</span> error<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>prev<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>prev<span class="token operator">-></span>data_len <span class="token operator">=</span> mbuf_offset<span class="token punctuation">;</span>m<span class="token operator">-></span>nb_segs <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>m<span class="token operator">-></span>pkt_len <span class="token operator">+=</span> mbuf_offset<span class="token punctuation">;</span>prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>mbuf_offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>mbuf_avail  <span class="token operator">=</span> cur<span class="token operator">-></span>buf_len <span class="token operator">-</span> RTE_PKTMBUF_HEADROOM<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// ...省略</span>error<span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>is_async<span class="token punctuation">)</span><span class="token function">async_iter_cancel</span><span class="token punctuation">(</span>async<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从代码里可以看到确实是内存池不够用了，但是只有在Guest里数据包很大，超过我们预设的MTU的时候才会出现，什么时候Guest会发送超过MTU大小的包到网卡呢？很容易想到的一个点就是各种的Offload，特别是和网卡相关的分包Offload。于是就找了一台业务机器的现场看了一下网卡的特性开启情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ethtool -k eth0</span>Features <span class="token keyword">for</span> eth0:rx-checksumming: on <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>tx-checksumming: on        tx-checksum-ipv4: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-checksum-ip-generic: on        tx-checksum-ipv6: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-checksum-fcoe-crc: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-checksum-sctp: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>scatter-gather: on        tx-scatter-gather: on        tx-scatter-gather-fraglist: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>tcp-segmentation-offload: off        tx-tcp-segmentation: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-tcp-ecn-segmentation: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-tcp6-segmentation: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>udp-fragmentation-offload: ongeneric-segmentation-offload: ongeneric-receive-offload: on<span class="token comment"># ...省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再找一台没有问题的机器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ethtool -k eth0</span>Features <span class="token keyword">for</span> eth0:rx-checksumming: on <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>tx-checksumming: on        tx-checksum-ipv4: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-checksum-ip-generic: on        tx-checksum-ipv6: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-checksum-fcoe-crc: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-checksum-sctp: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>scatter-gather: on        tx-scatter-gather: on        tx-scatter-gather-fraglist: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>tcp-segmentation-offload: off        tx-tcp-segmentation: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-tcp-ecn-segmentation: off <span class="token punctuation">[</span>requested on<span class="token punctuation">]</span>        tx-tcp-mangleid-segmentation: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>        tx-tcp6-segmentation: off <span class="token punctuation">[</span>fixed<span class="token punctuation">]</span>generic-segmentation-offload: on<span class="token comment"># ...省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现像TSO这种常用的Offload特性都关了，但是出问题的机器，比没出问题的机器，多了一个特性<code>udp-fragmentation-offload: on</code>，这个特性就是<code>UFO</code>，和TSO类似，TSO是TCP的offload，而UFO是UDP的offload，既然这里有不同，那是不是出问题里有应用会发送大的UDP包呢？再尝试抓包看下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># tcpdump -i eth0 udp</span>tcpdump: verbose output suppressed, use <span class="token parameter variable">-v</span> or <span class="token parameter variable">-vv</span> <span class="token keyword">for</span> full protocol decodelistening on eth0, link-type EN10MB <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>, capture size <span class="token number">65535</span> bytes<span class="token number">17</span>:55:43.880517 IP localhost.29784 <span class="token operator">></span> <span class="token number">192.168</span>.100.111.8333: UDP, length <span class="token number">9082</span><span class="token number">17</span>:55:43.880526 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.880528 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.880539 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.880541 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.880542 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.880543 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.881681 IP localhost.29784 <span class="token operator">></span> <span class="token number">192.168</span>.100.111.8333: UDP, length <span class="token number">9076</span><span class="token number">17</span>:55:43.881684 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.881686 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.881687 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.881689 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.881690 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.881692 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.882214 IP localhost.17670 <span class="token operator">></span> <span class="token number">192.168</span>.100.1.domain: <span class="token number">4442</span>+ PTR? <span class="token number">192.168</span>.100.1.in-addr.arpa. <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token number">17</span>:55:43.882341 IP <span class="token number">192.168</span>.100.1.domain <span class="token operator">></span> localhost.17670: <span class="token number">4442</span> NXDomain <span class="token number">0</span>/1/0 <span class="token punctuation">(</span><span class="token number">119</span><span class="token punctuation">)</span><span class="token number">17</span>:55:43.882828 IP localhost.29784 <span class="token operator">></span> <span class="token number">192.168</span>.100.111.8333: UDP, length <span class="token number">9046</span><span class="token number">17</span>:55:43.882835 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.882837 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.882850 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.882852 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.882853 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span class="token number">17</span>:55:43.882854 IP localhost <span class="token operator">></span> <span class="token number">192.168</span>.100.111: udp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没错，除了DNS的请求之外，业务还会发送一些超过9000长度的UDP包，这些UDP包会占用预期外的mbuf资源，知道了这个问题，那就尝试把ufo特性关闭一下看看效果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ethtoo -K eth0 ufo off</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭UFO之后，观察一段时间，虚拟机的网络恢复正常了。随后我们在测试环境也通过iperf复现了问题，便于后续的验证。</p><p>关闭UFO临时解决问题之余，又抛出来一个新的问题，为啥之前之前灰度的机器为什么没有出现同样的问题？为什么没有问题的机器里<code>udp-fragmentation-offload: on</code>这个特性直接消失了？</p><p>通过一些搜索，找到了答案，来着内核的官方<a href="https://www.kernel.org/doc/html/latest/networking/segmentation-offloads.html">文档: Segmentation Offloads</a>：</p><blockquote><p>UDP Fragmentation Offload<br>UDP fragmentation offload allows a device to fragment an oversized UDP datagram into multiple IPv4 fragments. Many of the requirements for UDP fragmentation offload are the same as TSO. However the IPv4 ID for fragments should not increment as a single IPv4 datagram is fragmented.</p><p>UFO is deprecated: modern kernels will no longer generate UFO skbs, but can still receive them from tuntap and similar devices. Offload of UDP-based tunnel protocols is still supported.</p></blockquote><p>原来UFO已经被废弃了，现代内核不会再发送大的UFO skbs，但是仍然允许从tuntap等类似设备上接收这些包。再看一下这俩机器的内核版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#uname -r</span><span class="token number">3.10</span>.0-514.el7.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#uname -r</span><span class="token number">5.14</span>.0-284.25.1.el9_2.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>确实差了不少。</p><p>最后呢，解决办法是将虚拟机的网卡配置调整了一下，修改成了：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interface</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>vhostuser<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mac</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>&#123;&#123;.MACAddress&#125;&#125;<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>unix<span class="token punctuation">'</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>&#123;&#123;.VhostPath&#125;&#125;<span class="token punctuation">'</span></span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>server<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>model</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>virtio<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>driver</span> <span class="token attr-name">queues</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>16<span class="token punctuation">'</span></span> <span class="token attr-name">rx_queue_size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>1024<span class="token punctuation">'</span></span> <span class="token attr-name">tx_queue_size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>1024<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>host</span> <span class="token attr-name">tso4</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">tso6</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">ufo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">ecn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">mrg_rxbuf</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>guest</span> <span class="token attr-name">tso4</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">tso6</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">ufo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span> <span class="token attr-name">ecn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>off<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>driver</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interface</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实TSO这个特性是在DPDK里关闭的，但是因为已经上线了不少业务，UFO在DPDK里关闭的话，会影响老虚拟机的热迁移，因此还是在qemu这侧关闭吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先需要解释一下标题，原谅我当了一回标题党，此UFO不是&lt;code&gt;Unidentified flying object&lt;/code&gt;，而是在网络中的一个Oflload卸载技术&lt;code&gt;UDP fragmentation offload&lt;/code&gt;。事情的起因是这样的，我们最近尝试将线上的虚拟机，从基于网卡SR-IOV+直通的方案，切换到基于DPDK+vhost-user的方案，以换取热迁移的效率提升。&lt;/p&gt;
&lt;p&gt;从之前的模拟压测和线上灰度效果来看，新的DPDK方案的性能和稳定性都处于很好的水平，在我们的场景下可以很好地满足需求。&lt;br&gt;直到灰度到某个业务的时候，发生了一些问题，导致了虚拟机的网络中断。</summary>
    
    
    
    <category term="Linux Kernel" scheme="https://www.ichenfu.com/categories/Linux-Kernel/"/>
    
    
    <category term="DPDK" scheme="https://www.ichenfu.com/tags/DPDK/"/>
    
    <category term="virtio" scheme="https://www.ichenfu.com/tags/virtio/"/>
    
    <category term="UFO" scheme="https://www.ichenfu.com/tags/UFO/"/>
    
  </entry>
  
  <entry>
    <title>在RHEL系统中快速抓取火焰图</title>
    <link href="https://www.ichenfu.com/2023/10/18/rhel-perf-flamegraphs/"/>
    <id>https://www.ichenfu.com/2023/10/18/rhel-perf-flamegraphs/</id>
    <published>2023-10-18T12:02:09.000Z</published>
    <updated>2023-10-18T03:18:04.078Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的好几篇Blog里，都使用了火焰图来对业务进行性能优化，之前为了抓取火焰图，需要用到好几个工具进行组合，流程还是比较麻烦的。随着RHEL的版本更新，Redhat提供了一个更简单快速的方法实现了一键抓取火焰图的功能。</p><span id="more"></span><p>这个功能在<code>RHEL 8.2</code>及以上版本可以使用，当然RHEL对应的衍生版比如<code>OracleLinux</code>、<code>AlmaLinux</code>、<code>RockyLinux</code>等也是可以直接使用的。</p><p>首先需要安装<code>perf</code>和<code>js-d3-flame-graph</code>这两个软件包：</p><pre class="line-numbers language-none"><code class="language-none"># yum install js-d3-flame-graph perf -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就可以通过<code>perf script flamegraph -a -F 99 sleep 60</code>命令抓取整个系统的火焰图了，其中<code>-a</code>参数表示需要记录整个系统的性能数据，<code>-F</code>参数指定每秒的收集频率，<code>sleep 60</code>表示收集60S的数据。</p><p>60秒后，命令自动退出并会在当前目录生成一个<code>flamegraph.html</code>文件，用任意浏览器打开这个文件，即可看到火焰图。</p><p>当然，如果要收集某个进程的火焰图，可以使用<code>perf script flamegraph -a -F 99 -p PID1,PID2 sleep 60</code>命令。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的好几篇Blog里，都使用了火焰图来对业务进行性能优化，之前为了抓取火焰图，需要用到好几个工具进行组合，流程还是比较麻烦的。随着RHEL的版本更新，Redhat提供了一个更简单快速的方法实现了一键抓取火焰图的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.ichenfu.com/categories/Linux/"/>
    
    
    <category term="火焰图" scheme="https://www.ichenfu.com/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    
    <category term="perf" scheme="https://www.ichenfu.com/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>反序列化AWS/阿里云样式的基于Query的API请求</title>
    <link href="https://www.ichenfu.com/2023/07/13/parse-aws-aliyun-like-api-request/"/>
    <id>https://www.ichenfu.com/2023/07/13/parse-aws-aliyun-like-api-request/</id>
    <published>2023-07-13T11:46:12.000Z</published>
    <updated>2023-07-24T08:40:29.193Z</updated>
    
    <content type="html"><![CDATA[<p>对于比较了解云计算的人来说，一定接触过AWS、阿里云的API接口，这两者的API调用方式很相似，当然具体谁参考谁这里就不深究了。以给EC2&#x2F;ECS添加Tag这个接口为例：</p><p>AWS:</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;ec2.amazonaws.com&#x2F;?Action&#x3D;CreateTags&amp;ResourceId.1&#x3D;ami-1a2b3c4d&amp;ResourceId.2&#x3D;i-1234567890abcdef0&amp;Tag.1.Key&#x3D;webserver&amp;Tag.1.Value&#x3D;&amp;Tag.2.Key&#x3D;stack&amp;Tag.2.Value&#x3D;Production&amp;AUTHPARAMS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阿里云：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;ecs.aliyuncs.com&#x2F;?Action&#x3D;TagResources&amp;RegionId&#x3D;cn-hangzhou&amp;ResourceId.1&#x3D;i-bp1j6qtvdm8w0z1o0****&amp;ResourceId.2&#x3D;i-bp1j6qtvdm8w0z1oP****&amp;ResourceType&#x3D;instance&amp;Tag.1.Key&#x3D;TestKey&amp;Tag.1.Value&#x3D;TestKey&amp;&lt;公共请求参数&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><p>这种样式的接口设计，其实没有什么复杂的，相对比较特殊的地方在于，如果需要传入一个数组，则需要使用类似下标一样的<code>Tag.N.Key</code>这种格式进行传递，这个传递方式，和已有的一些诸如<a href="https://github.com/google/go-querystring">google&#x2F;go-querystring</a>的传递方式都不太相同，总之是个很特殊的设计。</p><p>如果需要写一个类似的服务，使用和这两家相同的API格式的话，针对这种数组格式的请求反序列化是个挺麻烦的事，而且找了一圈也没有类似的开源项目做这个。</p><p>今天借助ChatGPT写了一个反序列化函数，专门用来实现服务端对类似形态API的反序列化，通过这个函数可以很方便的将Query反序列化成一个对应的Struct：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"encoding/json"</span><span class="token string">"fmt"</span><span class="token string">"net/url"</span><span class="token string">"reflect"</span><span class="token string">"strconv"</span><span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token keyword">type</span> TagRequest <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Action       <span class="token builtin">string</span>   <span class="token string">`query:"Action"`</span>RegionID     <span class="token builtin">string</span>   <span class="token string">`query:"RegionId"`</span>ResourceIds  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`query:"ResourceId"`</span>ResourceType <span class="token builtin">string</span>   <span class="token string">`query:"ResourceType"`</span>Tags         <span class="token punctuation">[</span><span class="token punctuation">]</span>Tag    <span class="token string">`query:"Tag"`</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> Tag <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Key   <span class="token builtin">string</span> <span class="token string">`query:"Key"`</span>Value <span class="token builtin">string</span> <span class="token string">`query:"Value"`</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Unmarshal</span><span class="token punctuation">(</span>queryStr <span class="token builtin">string</span><span class="token punctuation">,</span> output <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>values<span class="token punctuation">,</span> err <span class="token operator">:=</span> url<span class="token punctuation">.</span><span class="token function">ParseQuery</span><span class="token punctuation">(</span>queryStr<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">unmarshalData</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">unmarshalData</span><span class="token punctuation">(</span>values url<span class="token punctuation">.</span>Values<span class="token punctuation">,</span> output <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>outputVal <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token keyword">if</span> outputVal<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> reflect<span class="token punctuation">.</span>Ptr <span class="token punctuation">&#123;</span><span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"output must be a pointer"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>outputElem <span class="token operator">:=</span> outputVal<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>outputType <span class="token operator">:=</span> outputElem<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> outputType<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>field <span class="token operator">:=</span> outputType<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>tag <span class="token operator">:=</span> field<span class="token punctuation">.</span>Tag<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span><span class="token keyword">if</span> tag <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>value <span class="token operator">:=</span> values<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>fieldVal <span class="token operator">:=</span> outputElem<span class="token punctuation">.</span><span class="token function">FieldByName</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token keyword">if</span> field<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> reflect<span class="token punctuation">.</span>Slice <span class="token punctuation">&#123;</span>elemType <span class="token operator">:=</span> field<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> elemType<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> reflect<span class="token punctuation">.</span>Struct <span class="token punctuation">&#123;</span>prefix <span class="token operator">:=</span> tag <span class="token operator">+</span> <span class="token string">"."</span>arrIndex <span class="token operator">:=</span> <span class="token number">1</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>currKey <span class="token operator">:=</span> prefix <span class="token operator">+</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span>arrIndex<span class="token punctuation">)</span>currValue <span class="token operator">:=</span> values<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>currKey<span class="token punctuation">)</span><span class="token keyword">if</span> currValue <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>currSliceVal <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>currValue<span class="token punctuation">)</span>fieldVal<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>fieldVal<span class="token punctuation">,</span> currSliceVal<span class="token punctuation">)</span><span class="token punctuation">)</span>arrIndex<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>prefix <span class="token operator">:=</span> tag <span class="token operator">+</span> <span class="token string">"."</span>objIndex <span class="token operator">:=</span> <span class="token number">1</span>outer <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token keyword">for</span> outer <span class="token punctuation">&#123;</span>innerValues <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span><span class="token keyword">for</span> innerKey<span class="token punctuation">,</span> innerValue <span class="token operator">:=</span> <span class="token keyword">range</span> values <span class="token punctuation">&#123;</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>innerKey<span class="token punctuation">,</span> prefix<span class="token operator">+</span>strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>objIndex<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>innerValues<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimPrefix</span><span class="token punctuation">(</span>innerKey<span class="token punctuation">,</span> prefix<span class="token operator">+</span>strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>objIndex<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">,</span> innerValue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>innerValues<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>newStructPtr <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>elemType<span class="token punctuation">)</span>err <span class="token operator">:=</span> <span class="token function">unmarshalData</span><span class="token punctuation">(</span>innerValues<span class="token punctuation">,</span> newStructPtr<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span>fieldVal<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>fieldVal<span class="token punctuation">,</span> newStructPtr<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>objIndex<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fieldVal<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queryStr <span class="token operator">:=</span> <span class="token string">"?Action=TagResources&amp;RegionId=cn-hangzhou&amp;ResourceId.1=i-bp1j6qtvdm8w0z1o0&amp;ResourceId.2=i-bp1j6qtvdm8w0z1oP&amp;ResourceType=instance&amp;Tag.1.Key=TestKey&amp;Tag.1.Value=TestValue&amp;Tag.2.Key=TestKey&amp;Tag.2.Value=TestValue"</span>req <span class="token operator">:=</span> TagRequest<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>err <span class="token operator">:=</span> <span class="token function">Unmarshal</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimLeft</span><span class="token punctuation">(</span>queryStr<span class="token punctuation">,</span> <span class="token string">"?"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>jsonOutput<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">MarshalIndent</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"  "</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Unmarshaled output:"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>jsonOutput<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">% go run main.goUnmarshaled output: <span class="token punctuation">&#123;</span>  <span class="token string">"Action"</span><span class="token builtin class-name">:</span> <span class="token string">"TagResources"</span>,  <span class="token string">"RegionID"</span><span class="token builtin class-name">:</span> <span class="token string">"cn-hangzhou"</span>,  <span class="token string">"ResourceIds"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token string">"i-bp1j6qtvdm8w0z1o0"</span>,    <span class="token string">"i-bp1j6qtvdm8w0z1oP"</span>  <span class="token punctuation">]</span>,  <span class="token string">"ResourceType"</span><span class="token builtin class-name">:</span> <span class="token string">"instance"</span>,  <span class="token string">"Tags"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token string">"Key"</span><span class="token builtin class-name">:</span> <span class="token string">"TestKey"</span>,      <span class="token string">"Value"</span><span class="token builtin class-name">:</span> <span class="token string">"TestValue"</span>    <span class="token punctuation">&#125;</span>,    <span class="token punctuation">&#123;</span>      <span class="token string">"Key"</span><span class="token builtin class-name">:</span> <span class="token string">"TestKey"</span>,      <span class="token string">"Value"</span><span class="token builtin class-name">:</span> <span class="token string">"TestValue"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>嗯，ChatGPT牛逼！为了方便大家使用，我创建了一个项目<a href="https://github.com/C0reFast/aws-querystring">c0refast&#x2F;aws-querystring</a>，可以方便地作为库使用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"encoding/json"</span><span class="token string">"fmt"</span><span class="token string">"net/url"</span><span class="token string">"github.com/c0refast/aws-querystring/query"</span><span class="token punctuation">)</span><span class="token keyword">type</span> TagRequest <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Action       <span class="token builtin">string</span>   <span class="token string">`query:"Action"`</span>RegionID     <span class="token builtin">string</span>   <span class="token string">`query:"RegionId"`</span>ResourceIds  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`query:"ResourceId"`</span>ResourceType <span class="token builtin">string</span>   <span class="token string">`query:"ResourceType"`</span>Tags         <span class="token punctuation">[</span><span class="token punctuation">]</span>Tag    <span class="token string">`query:"Tag"`</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> Tag <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Key   <span class="token builtin">string</span> <span class="token string">`query:"Key"`</span>Value <span class="token builtin">string</span> <span class="token string">`query:"Value"`</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queryStr <span class="token operator">:=</span> <span class="token string">"Action=TagResources&amp;RegionId=cn-hangzhou&amp;ResourceId.1=i-bp1j6qtvdm8w0z1o0&amp;ResourceId.2=i-bp1j6qtvdm8w0z1oP&amp;ResourceType=instance&amp;Tag.1.Key=TestKey&amp;Tag.1.Value=TestValue&amp;Tag.2.Key=TestKey&amp;Tag.2.Value=TestValue"</span>urlValues<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> url<span class="token punctuation">.</span><span class="token function">ParseQuery</span><span class="token punctuation">(</span>queryStr<span class="token punctuation">)</span>req <span class="token operator">:=</span> TagRequest<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>err <span class="token operator">:=</span> query<span class="token punctuation">.</span><span class="token function">BindQuery</span><span class="token punctuation">(</span>urlValues<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>jsonOutput<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">MarshalIndent</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"  "</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Unmarshaled output:"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>jsonOutput<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于比较了解云计算的人来说，一定接触过AWS、阿里云的API接口，这两者的API调用方式很相似，当然具体谁参考谁这里就不深究了。以给EC2&amp;#x2F;ECS添加Tag这个接口为例：&lt;/p&gt;
&lt;p&gt;AWS:&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;https:&amp;#x2F;&amp;#x2F;ec2.amazonaws.com&amp;#x2F;?Action&amp;#x3D;CreateTags
&amp;amp;ResourceId.1&amp;#x3D;ami-1a2b3c4d
&amp;amp;ResourceId.2&amp;#x3D;i-1234567890abcdef0
&amp;amp;Tag.1.Key&amp;#x3D;webserver
&amp;amp;Tag.1.Value&amp;#x3D;
&amp;amp;Tag.2.Key&amp;#x3D;stack
&amp;amp;Tag.2.Value&amp;#x3D;Production
&amp;amp;AUTHPARAMS&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;阿里云：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;https:&amp;#x2F;&amp;#x2F;ecs.aliyuncs.com&amp;#x2F;?Action&amp;#x3D;TagResources
&amp;amp;RegionId&amp;#x3D;cn-hangzhou
&amp;amp;ResourceId.1&amp;#x3D;i-bp1j6qtvdm8w0z1o0****
&amp;amp;ResourceId.2&amp;#x3D;i-bp1j6qtvdm8w0z1oP****
&amp;amp;ResourceType&amp;#x3D;instance
&amp;amp;Tag.1.Key&amp;#x3D;TestKey
&amp;amp;Tag.1.Value&amp;#x3D;TestKey
&amp;amp;&amp;lt;公共请求参数&amp;gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="Golang" scheme="https://www.ichenfu.com/tags/Golang/"/>
    
    <category term="AWS" scheme="https://www.ichenfu.com/tags/AWS/"/>
    
    <category term="Aliyun" scheme="https://www.ichenfu.com/tags/Aliyun/"/>
    
    <category term="ChatGPT" scheme="https://www.ichenfu.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>DIY一个8盘位全闪NAS</title>
    <link href="https://www.ichenfu.com/2023/01/26/diy-a-8bay-ssd-nas/"/>
    <id>https://www.ichenfu.com/2023/01/26/diy-a-8bay-ssd-nas/</id>
    <published>2023-01-26T07:43:28.000Z</published>
    <updated>2023-02-10T02:45:27.842Z</updated>
    
    <content type="html"><![CDATA[<p>接上篇<a href="/2022/11/05/lsi-raid-controller-and-hba-complete-listing-plus-oem-models/">LSI RAID卡芯片和各个OEM对应卡型号列表</a>里说的后续DIY NAS的想法，经过快3个月的时间，终于来更新整个DIY过程了，总结起来在整个过程中，收获的主要还是折腾的乐趣，要说折腾的尽头是白群晖，随着时间的推移，个人还是比较认同的，不过不得不说白群晖确实太贵了，都说群晖是买软件送硬件，但是这软件也太贵了点。</p><span id="more"></span><h1 id="需求描述和分析"><a href="#需求描述和分析" class="headerlink" title="需求描述和分析"></a>需求描述和分析</h1><p>说起来，为啥会有个DIY NAS的需求呢？一个重要的原因是家里的小宝贝出生了，不知不觉也拍了好多的照片和视频，还是希望能更长久的把这些记忆保留下来。另外呢，之前更新自己的电脑，淘汰下来一套i5 6500 CPU加16G内存以及主板的准系统，买个机箱还有电源就直接可以用了，本着废物利用的原则，做个NAS也不亏，而且还多了很多可玩性。</p><p>其实单纯从保存数据来说，将数据存放到任何一个公有云的对象存储上，是个最终极的方案，因为目前各个厂商提供的对象存储数据持久性SLA都达到了11或者12个9（99.999999999%-99.9999999999%），这基本意味着几乎不存在数据丢失的可能性了。但是确实这个方案也是最贵的，毕竟每TB存储每月都需要消耗对应的存储费用，随着时间增长，即使是最便宜的冷归档类型，也依然是个不小的消耗。</p><p>那到底需要多少的存储容量呢？针对我个人而言，目前可预见的容量，应该不会超过10T，当前1-2年内所需求的容量更小，大概只需要1到2T的样子。</p><p>针对这个容量，其实已经可以考虑全SSD的存储方案了，其实相比于使用HDD的方案，纯SSD的NAS有以下几个好处：首先是噪音角度，相比HDD运行时的“炒豆子”声来说，SSD 0噪音，这可以直接解决夜间安静环境下HDD低频噪音对睡眠质量的影响；其次是稳定性和数据安全角度，根据我们公司数据中心有比较大规模的SSD和HDD的使用经验，同时参考<a href="https://www.backblaze.com/blog/ssd-drive-stats-mid-2022-review/">backblaze提供的统计数据</a>，可以看出SSD的稳定性远超过HDD，这带来了两个优势，一个是相比HDD，SSD损坏的概率低，这可以减少存储池修复的可能性，另外因为读写速度上SSD快很多，在坏盘的情况下，SSD也可以做到更坏的修复速度，从而可以提供更好的数据持久性。</p><p>当然SSD依然还是有缺点的，很明显当前SSD比HDD依然贵很多，以当前的价格来说，SSD成本大约0.4元&#x2F;GB（大多数1T SATA SSD），HDD大概只有0.12元&#x2F;GB（西数HC550 16T）。但是对于我目前的容量需求来说，使用SSD的成本相比HDD没有差距太大，多花的那部分成本，对于0噪音来说是相当值得的。</p><p>除了磁盘的选型，还有一些其他的需求，诸如盘位数量大于等于4，硬盘需要支持热拔插，存储池可以动态扩容，移动端、桌面端数据自动同步等等，不过这些也都算是比较基础的需求了。</p><h1 id="硬盘笼选择"><a href="#硬盘笼选择" class="headerlink" title="硬盘笼选择"></a>硬盘笼选择</h1><p>针对硬盘热拔插的需求，肯定还是要搞个硬盘笼的，不管怎么说，相比于直接把硬盘塞机箱里，有个热拔插硬盘笼一下子逼格就上来了。</p><p>所以一直花了不少精力去找合适的硬盘笼，主要还是集中于服务器的拆机件，这里给几个当时考虑的一些方案。</p><h2 id="浪潮12盘位3-5寸硬盘笼"><a href="#浪潮12盘位3-5寸硬盘笼" class="headerlink" title="浪潮12盘位3.5寸硬盘笼"></a>浪潮12盘位3.5寸硬盘笼</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/images/inspur-12bay-front.jpg"></div><div class="group-picture-column"><img src="/images/inspur-12bay-back.jpg"></div></div></div><p>首先第一个选择是买浪潮的12盘位3.5寸硬盘笼，目前的价格大概150块钱的样子，还挺便宜，感觉应该都是当初Chia矿老板淘汰下来的，这些硬盘笼基本都有大4P的电源接口以及MiniSAS（SFF8087）接口，使用起来还是比较方便的，当然缺点是确实占地比较大，毕竟是适配的2U机箱，因为本来也一直坚持全闪的方案，所以3.5寸的硬盘位就没有必要了，即使很便宜，依然放弃了这个方案。</p><h2 id="Intel-8盘位热插拔笼子-8-AnyBay"><a href="#Intel-8盘位热插拔笼子-8-AnyBay" class="headerlink" title="Intel 8盘位热插拔笼子(8 AnyBay)"></a>Intel 8盘位热插拔笼子(8 AnyBay)</h2><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/images/intel-8-anybay-front.jpg"></div><div class="group-picture-column"><img src="/images/intel-8-anybay-back.jpg"></div></div></div><p>这是Intel一个颜值和功能都超级能打的硬盘笼，具体的参数可以参考<a href="https://www.intel.com/content/www/us/en/products/sku/99083/2u-hotswap-8x2-5inch-sasnvme-combo-drive-bay-kit-a2u8x25s3phs/specifications.html">Intel的Spec文档</a>（不得不说Intel的文档写的是真的好），甚至当前这个时间点，依然在量产状态，这个笼子一般来说都是在2U机箱上做竖插24盘位的组件的，这几乎是我心目中最理想的硬盘笼选择，8盘位AnyBay，支持SATA、SAS、U.2 NVMe接口的硬盘，特别是在现在咸鱼有大量的U.2接口的大容量企业级SSD，价格十分友好。最关键的是这个硬盘笼的尺寸非常完美，可以无缝的塞进两个5.25英寸光驱位中，网上也有这个硬盘笼搭配银欣（SilverStone）SG02-F机箱组NAS的方案：<a href="https://www.bilibili.com/read/cv16906380">全网首发【8盘位热插拔NVMe SSD NAS】DIY指南简章</a>，不得不说这个方案真的让人流口水，但确实不得不说成本太高了。</p><p>这个硬盘笼呢，什么都好，就是成本太高，不仅仅笼子本身（大约1100+）更重要的是其配套的组件，首先这个硬盘笼是MiniSAS HD（SFF‑8643）接口的，支持这个接口的HBA或者RAID卡也比较贵，其次如果说要支持8个NVMe硬盘的话，需要准备8个OcuLink接口，那PCIe转OcuLink接口的转接卡又是不小的支出。更重要的是，8个NVMe需要32个PCIe lane，这直接超出了当前大部分平台的能力，基本只有服务器平台的CPU+主板才能支持这么多的PCIe lane，成本很可观。最后还有一个不得不考虑的问题，U.2 NVMe硬盘一般来说功耗都比较高，很多盘能到10几20W往上，如果是8块硬盘，那整体功耗可能会超过100W，所以散热的问题就不得不考虑了，这个笼子如果插NVMe硬盘的话，需要额外的散热。</p><p>所以呢，东西虽好，但确实不符合我当前的需求和预算（流下贫穷的泪水）。据说H3C也有类似的笼子，价格要便宜1半，如果大家有类似的需求可以考虑。好像类似的8盘位AnyBay硬盘笼，各家OEM都有，但是好像好买且价格合适的不多。</p><h2 id="Intel-8盘位热插拔笼子-4-AnyBay-4-SATA-SAS"><a href="#Intel-8盘位热插拔笼子-4-AnyBay-4-SATA-SAS" class="headerlink" title="Intel 8盘位热插拔笼子(4 AnyBay + 4 SATA&#x2F;SAS)"></a>Intel 8盘位热插拔笼子(4 AnyBay + 4 SATA&#x2F;SAS)</h2><p>这是另外一个Intel的硬盘笼子，大概可以算是上面笼子的低配版，<a href="https://www.intel.com/content/www/us/en/products/sku/82790/hotswap-backplane-pcie-combination-drive-cage-kit-for-p4000-server-chassis-fup8x25s3nvdk-2-5in-nvme-ssd/specifications.html">文档看这里</a>，这个笼子支持4个NVMe + 4个SATA&#x2F;SAS硬盘，价格在淘宝也相对便宜，看到加上PCIe转接卡大概1000不到可以拿下，其实是个不错的选择，但是依然超出我的预算不少（继续流下贫穷的泪水）。</p><h2 id="Intel-8盘位热插拔笼子-8-SATA-SAS"><a href="#Intel-8盘位热插拔笼子-8-SATA-SAS" class="headerlink" title="Intel 8盘位热插拔笼子(8 SATA&#x2F;SAS)"></a>Intel 8盘位热插拔笼子(8 SATA&#x2F;SAS)</h2><p><img src="/images/intel-8-sas.jpg"></p><p>Intel还有一种硬盘笼（Intel出的好东西真不少啊），<a href="https://www.intel.com/content/www/us/en/products/sku/60221/spare-8x2-5-hotswap-drive-cage-kit-fup8x25hsdks/specifications.html">文档看这里</a>，这个笼子支持8个SATA&#x2F;SAS硬盘，使用两个MiniSAS（SFF8087）接口，是一开始我选中的方案，整体还是很平衡的，淘宝大概400不到，在我找到下面的硬盘笼之前，一度准备剁手入了。</p><h2 id="HP热插拔380-G6-G7硬盘笼"><a href="#HP热插拔380-G6-G7硬盘笼" class="headerlink" title="HP热插拔380 G6&#x2F;G7硬盘笼"></a>HP热插拔380 G6&#x2F;G7硬盘笼</h2><p><img src="/images/hp-8-sas.jpg"></p><p>这个是我最后选择的笼子，这个硬盘笼原本是给HP DL380G6&#x2F;G7升级16盘位的套件，在HP那边的编号是：<code>507690-001</code>和<code>516914-B21</code>（这俩编号是一个东西），这个套件包含的几个组件和对应的物料编号如下：</p><blockquote><p>硬盘笼子：463173-001 496074-001<br>硬盘背板：507690-001 451283-002<br>硬盘供电线：514217-001<br>硬盘SAS数据线：498425-001 493228-005</p></blockquote><p>为什么我选择这个硬盘笼子呢，因为它真的便宜，笼子加上背板、送供电线和两根SAS线，只需要50块钱，当然是不带硬盘托架的，不过算上硬盘托架的价钱也只需要80。80块钱真买不了上当和吃亏。说实话它也有一些小问题，比如坑爹的HP不知道为啥要设计成横向的两个4盘位，尺寸比竖向8盘位相比宽了一点点，直接导致没办法塞进2个5.25英寸光驱位。另外电源接口的设计也比较恶心，是向外的，如果想塞进机箱，那突出来的电源线会成为一个大问题，另外HP的电源接口定义也是每代一改，虽然复用了10pin的接口，但是定义并不标准，导致我花了非常长的时间去寻找各个pin的定义，生怕弄错接口定义把背板烧了，最终还是在一个德语的论坛找到<a href="https://www.hardwareluxx.de/community/threads/adapter-auf-hp-10-pin-stromanschlu%C3%9F-gesucht-f%C3%BCr-hp-sas-backplane.865625/page-2#post-19825023">一个评论</a>说了这个硬盘笼子的定义，需要说明的是这个背板不接3.3V的供电也没有影响，所以也是淘宝了两根大4P的电源线和10pin线，自己DIY了一个电源线，最终把这个硬盘盒的供电问题解决。总的来说，主要这个笼子实在是太便宜了，便宜到它的这几个缺点都可以忍受（还是流下贫穷的泪水）。</p><h1 id="RAID-HBA卡选择"><a href="#RAID-HBA卡选择" class="headerlink" title="RAID&#x2F;HBA卡选择"></a>RAID&#x2F;HBA卡选择</h1><p>针对上面几个硬盘笼，特别是最终我选的硬盘笼，都使用了MiniSAS（SFF8087）接口，所以要想使用硬盘笼的话，需要有支持MiniSAS接口的SATA控制器或者RAID&#x2F;HBA卡，根据之前的调查，大致有几种方案：</p><pre><code>1. 可以使用MiniSAS转4SATA线实现，不过需要注意的是，这种线是区分正反的，正向线是MiniSAS口转4SATA，需要买反接线，将4SATA转换成MiniSAS口，从而实现将主板上的4个SATA口转成一个MiniSAS口。2. 市面上还有一些基于类似ASM1166（或者类似芯片）的PCI-E转SFF-8087转接卡，但ASM1166原生只支持6SATA Port，是否两个SFF-8087端口的8个端口都能使用，这个存疑。   另外还有也有一些M.2转8口SATA扩展卡也是用的两个SFF-8087转接卡，理论上也可以使用。3. 使用拆机的服务器HBA卡，比如基于LSI SAS 2008/2308的一众原厂或者OEM HBA卡。</code></pre><p>最终我还是选择了相对成熟的HBA卡方案，一顿精挑细选，最终选了SuperMicro家的<code>AOC-S2308L-L8I 9217-8i</code>，基于SAS 2308芯片，PCIe 3.0 x8的接口，支持两个SFF-8087接口，这是一张OEM卡，对应的原厂卡型号是<code>LSI SAS9217-8i</code>，市面上除了SuperMicro之外，还有很多OEM也会出相同芯片的卡，比如浪潮、IBM等等，选择还是比较多的。我选的是2308的方案，这个芯片算是2008芯片的升级，其实区别不大，最主要的升级就是从PCIe 2.0 x8变成了PCIe 3.0 x8，整体带宽会高点。另外需要注意的一点是，这两个芯片有两种固件：IT（Initiator Target）模式和IR（Integrated RAID）模式，IT模式是类似HBA卡的直通模式，没办法组建RAID；IR模式是类似RAID卡的模式，可以组建简单的RAID0和RAID1。另外这两种固件是可以互刷的，区别只是在产品名字上是9207还是9217（9217是IR模式，9207是IT模式，所以我买的卡也是原厂IR模式刷的IT固件）。最后其实这个卡有个比较大的散热方面的问题，根据原厂的<a href="https://docs.broadcom.com/doc/12353331">User Guide文档</a>。这张卡默认情况下有接近10W（默认9.8W，最大16W）的功耗，且最低要求<code>200 linear feet per minute</code>的风量，在服务器环境下散热都不是问题，但是放到家用的机箱里，如果没有主动散热的情况下，这张卡会非常的烫手！所以最终我又找了一个12cm的风扇专门对着卡的散热片吹，从而解决散热问题。</p><h1 id="硬盘选择"><a href="#硬盘选择" class="headerlink" title="硬盘选择"></a>硬盘选择</h1><p>上面的这些组件搞定，最终就是买硬盘了，之前提到现在全新的SATA SSD大概0.4元&#x2F;GB，一块1TB的SSD大概400左右，说实话还是不便宜的，所以我又勇敢的选择了大船货！其实现在二手拆机SSD，量最大，最划算的还是U.2的硬盘，不到1000块钱可以买到4T左右的企业级SSD，而且这些企业级SSD寿命极高，稳定性也相当好，而且相比于SATA接口，U.2因为是PCIe链路，可以做到传输层的数据保护，可惜的是咱们的硬盘笼不支持。于是就只能选择SATA接口的SSD，一下子可选范围就少了不少，最终还是选了当前比较火的Sandisk&#x2F;闪迪云盘ECO，但是相比于更火的1.92T容量的版本，我最终买了960G容量的版本，相比于1.92T这个容量点，我猜960G容量用来做系统盘的概率更大点，说不准能抽奖抽到写入量超低的盘😁。相比于全新盘，这个拆机盘的价格就很实惠了。目前的价格是960G容量版本230块，不到0.24元&#x2F;GB，属实是相当划算了。</p><h1 id="NAS系统选择"><a href="#NAS系统选择" class="headerlink" title="NAS系统选择"></a>NAS系统选择</h1><p>所有硬件的问题搞定，最后就只剩下软件层面的选择了，到底该用什么系统呢？一开始想使用TrueNAS，主要是看中ZFS的能力，但是试用了一小段时间TrueNAS之后，感觉这系统是真的很难用，门槛太高了，虽然运维这玩意对我来说并不是太大的瓶颈，但是确实各个方面都不太好用，特别是相关的软件生态上差很多。<br>于是乎就又试了试黑群晖，一开始我其实是抵制黑群晖的，因为有点担心数据安全问题，不确定会不会哪天就崩了，但是试用了一下之后，觉得确实群晖的生态做的太好了，体验拉满。于是就去简单研究了一下黑群晖的实现原理，发现其实黑群晖的相关项目都是开源的，都放在了<a href="https://github.com/RedPill-TTG">RedPill-TTG</a>这个组织下，其中最关键的对群晖内核的hack都在<a href="https://github.com/RedPill-TTG/redpill-lkm">RedPill-TTG&#x2F;redpill-lkm</a>这个项目里，大致翻了翻代码，基本上就是通过加载模块的方式，欺骗群晖的内核，让其认为自己是跑在群晖专有的硬件上。了解了之后，黑群晖在我心目中好感倍增，话说感觉群晖这绝对是套路满满，都说黑群晖的尽头是白群。估计群晖官方默许黑群晖行为的原因大概和Windows一样，反正最终都会买我。</p><p>不过相比于直接把群晖跑在裸机上，我采取了一个另外的方法，把群晖跑在了虚拟机里，这样做的目的主要也是为了方便以后迁移，对我来说当前的硬件平台只是个相对临时的解决方案，为了后续能更好的跨平台迁移，所以我选择将黑群晖跑在虚拟机里，而对于HBA卡来说，采取的是硬件直通的方式直通给虚拟机，从而确保SMART等功能的正常使用。这里分享一下我现在用的虚拟机的XML，有需要的可以参考一下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>domain</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>kvm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Synology<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uuid</span><span class="token punctuation">></span></span>5ce24e3b-627b-468a-bcd5-53ff58d9731d<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>uuid</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>memory</span><span class="token punctuation">></span></span>8388608<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>memory</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currentMemory</span><span class="token punctuation">></span></span>8388608<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentMemory</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>memoryBacking</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hugepages</span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>memoryBacking</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>vcpu</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>vcpu</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>os</span> <span class="token attr-name">firmware</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>efi<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>firmware</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>feature</span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>no<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>secure-boot<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>firmware</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span> <span class="token attr-name">arch</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x86_64<span class="token punctuation">"</span></span> <span class="token attr-name">machine</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>q35<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>hvm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boot</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hd<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>os</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>features</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>acpi</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>apic</span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>features</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpu</span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>host-passthrough<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>clock</span> <span class="token attr-name">offset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timer</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rtc<span class="token punctuation">"</span></span> <span class="token attr-name">tickpolicy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catchup<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timer</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pit<span class="token punctuation">"</span></span> <span class="token attr-name">tickpolicy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>delay<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timer</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hpet<span class="token punctuation">"</span></span> <span class="token attr-name">present</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>clock</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pm</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>suspend-to-mem</span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>suspend-to-disk</span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pm</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>devices</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>emulator</span><span class="token punctuation">></span></span>/usr/libexec/qemu-kvm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>emulator</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>disk</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">device</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>disk<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>driver</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>qemu<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>raw<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">file</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/data0/Synology/boot.img<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">dev</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sda<span class="token punctuation">"</span></span> <span class="token attr-name">bus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>usb<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>disk</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>interface</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bridge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">bridge</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>br0<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mac</span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>11:22:33:44:55:66<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>model</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>virtio<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>interface</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>console</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pty<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hostdev</span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subsystem<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pci<span class="token punctuation">"</span></span> <span class="token attr-name">managed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>address</span> <span class="token attr-name">domain</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">bus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">function</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hostdev</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>memballoon</span> <span class="token attr-name">model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>none<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>graphics</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>vnc<span class="token punctuation">'</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>-1<span class="token punctuation">'</span></span> <span class="token attr-name">autoport</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>yes<span class="token punctuation">'</span></span> <span class="token attr-name">listen</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0.0.0.0<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listen</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>address<span class="token punctuation">'</span></span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>0.0.0.0<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>graphics</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>model</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>vga<span class="token punctuation">'</span></span> <span class="token attr-name">vram</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>16384<span class="token punctuation">'</span></span> <span class="token attr-name">heads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>1<span class="token punctuation">'</span></span> <span class="token attr-name">primary</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>yes<span class="token punctuation">'</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>devices</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>domain</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结和后续"><a href="#总结和后续" class="headerlink" title="总结和后续"></a>总结和后续</h1><p>目前的这套NAS方案已经运行了2个多月，看起来还算稳定，这段时间内没出现过大的问题。如果折腾半天就只为了存点照片也有点浪费，所以除了存储功能之外，我又跑了个PCDN业务，目前收益也还不错，我是100M的上传带宽，目前每天大概能有个5块钱的收益，至少电费能覆盖了，跑着玩玩吧~</p><p>想想当前这套还有什么不足，个人觉得一个比较大的缺点是占地，目前我是用了乔斯伯的V4做的机箱，但是硬盘笼是不太好直接放进机箱了，所以只是简单的放在了外壳上，整体相比于家用的NAS产品还是大了一圈，另外确实硬盘笼比双5.25寸光驱位大了点，即使后续换了机箱，可能也不太好直接放进去。</p><p>另外就是CPU这些硬件配置了，一方面当前这颗CPU TDP还是比较大的，65W，必须有主动散热，另外HBA卡也需要主动散热，所以离真正的0噪音还有点距离，理论上换用嵌入式的低功耗CPU+SATA转MiniSAS的方案，可以做到整机完全没有任何机械活动的部件，做到真正意义上的0噪音。</p><p>最后就是另一个方向，换到稍微低端点的数据中心CPU+主板，功耗会高一些，但是可扩展性会极大的增强，包括ECC内存以及U.2硬盘、IPMI这些都可以支持。具体往后该如何演进，还是等待当前套系统继续运行一段时间吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;接上篇&lt;a href=&quot;/2022/11/05/lsi-raid-controller-and-hba-complete-listing-plus-oem-models/&quot;&gt;LSI RAID卡芯片和各个OEM对应卡型号列表&lt;/a&gt;里说的后续DIY NAS的想法，经过快3个月的时间，终于来更新整个DIY过程了，总结起来在整个过程中，收获的主要还是折腾的乐趣，要说折腾的尽头是白群晖，随着时间的推移，个人还是比较认同的，不过不得不说白群晖确实太贵了，都说群晖是买软件送硬件，但是这软件也太贵了点。&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="NAS" scheme="https://www.ichenfu.com/tags/NAS/"/>
    
    <category term="黑群晖" scheme="https://www.ichenfu.com/tags/%E9%BB%91%E7%BE%A4%E6%99%96/"/>
    
    <category term="SSD" scheme="https://www.ichenfu.com/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>分享一个记录LSI RAID卡芯片和各个OEM对应卡型号列表的神贴</title>
    <link href="https://www.ichenfu.com/2022/11/05/lsi-raid-controller-and-hba-complete-listing-plus-oem-models/"/>
    <id>https://www.ichenfu.com/2022/11/05/lsi-raid-controller-and-hba-complete-listing-plus-oem-models/</id>
    <published>2022-11-05T13:17:50.000Z</published>
    <updated>2023-01-29T01:28:30.170Z</updated>
    
    <content type="html"><![CDATA[<p>最近想买一张拆机的HBA卡组一个NAS玩玩，目前用SAS 2308的拆机OEM HBA卡（IT Mode，也可以刷固件刷成IR Mode从而直接变成RAID卡，但是只支持RAID 0, 1, 1E和10）只需要不到100块钱，非常划算，除了功耗高点（差不多10W）比较热之外，感觉没啥缺点。</p><p>于是就被各种原厂的或者OEM厂的各种型号搞晕了，因为基于这个芯片的各种OEM马甲卡实在太多了。于是乎就找到了一篇神贴，帖子里覆盖了几乎所有的LSI的RAID卡芯片以及大部分国外厂商对应的OEM卡型号，而且一直在更新，最新的一些SAS芯片也有记录，比较可惜的是国内的一些OEM厂商，特别是在淘宝保有量相当大的浪潮的OEM卡型号没有记录。</p><p>帖子的地址在：<a href="https://forums.servethehome.com/index.php?threads/lsi-raid-controller-and-hba-complete-listing-plus-oem-models.599/">LSI RAID Controller and HBA Complete Listing Plus OEM Models</a>。有需要的可以参考一下。</p><p>后续组NAS的经历我也会持续分享，敬请关注~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近想买一张拆机的HBA卡组一个NAS玩玩，目前用SAS 2308的拆机OEM HBA卡（IT Mode，也可以刷固件刷成IR Mode从而直接变成RAID卡，但是只支持RAID 0, 1, 1E和10）只需要不到100块钱，非常划算，除了功耗高点（差不多10W）比较热之外</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="LSI" scheme="https://www.ichenfu.com/tags/LSI/"/>
    
    <category term="RAID" scheme="https://www.ichenfu.com/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>在移动硬盘盒上启用SSD的Trim功能</title>
    <link href="https://www.ichenfu.com/2022/10/05/enable-trim-on-usb-attached-scsi-ssds/"/>
    <id>https://www.ichenfu.com/2022/10/05/enable-trim-on-usb-attached-scsi-ssds/</id>
    <published>2022-10-05T11:57:02.000Z</published>
    <updated>2023-01-29T01:28:30.170Z</updated>
    
    <content type="html"><![CDATA[<p>最近折腾了一小段时间的PCDN，家里刚好有一个闲置的JetsonNano和一块闲置的SSD，刚好可以跑跑PCDN，每天挣个宽带钱。具体跑的哪家，就不说了，说说在这过程中遇到的一个小问题：一般来说，PCDN或者类似的业务，对磁盘的写入压力还是比较大的，虽然可能平均的写入带宽并不高，但是也架不住每天读写的时间相当长，虽然我这块SSD是闲置的，但好歹是个传家宝，不管怎么说，还是有那么点点心疼的，肯定是不太希望哪天这SSD被写坏了。</p><p>在这种场景下，尽可能延长SSD的写入寿命就很重要了，而方法之一呢，就是想办法把SSD的<code>Trim</code>命令给用上。</p><p>用上<code>Trim</code>命令之前，可以先简单了解一下背后的逻辑，具体的可以参考<a href="https://zh.wikipedia.org/wiki/Trim%E5%91%BD%E4%BB%A4">Wiki</a>，简单来说呢，因为SSD依赖垃圾回收机制来平衡NAND的磨损，但是呢具体到一整个LBA空间，只有文件系统知道哪些数据块是有效数据，所以就需要通过<code>Trim</code>命令，建立文件系统空闲空间和SSD底层数据块的关联，从而让SSD的主控更好的进行垃圾回收操作，一般来说，合理的使用Trim，可以有效的提高SSD的性能和寿命。当然了，<code>Trim</code>命令是ATA指令集里的，也就是SATA接口SSD才会有，对于SCSI以及SAS接口SSD，还有NVMe SSD来说，也有相应的<code>UNMAP</code>和<code>Deallocate</code>指令，作用都是一样的。</p><p>一般来说，在Linux下，一个设备是否支持<code>Trim</code>操作，可以通过<code>lsblk --discard</code>进行查看，当输出中的<code>DISC-GRAN</code>和<code>DISC-MAX</code>列不为0时，说明这个设备是支持<code>Trim</code>操作的：</p><span id="more"></span><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jetson-nano:chenfu:<span class="token comment"># lsblk --discard</span>NAME        DISC-ALN DISC-GRAN DISC-MAX DISC-ZEROsda                <span class="token number">0</span>        0B       0B         <span class="token number">0</span>mmcblk1            <span class="token number">0</span>        4M      76M         <span class="token number">0</span>└─mmcblk1p1        <span class="token number">0</span>        4M      76M         <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如在我这个JetsonNano上，可以看到我外接的这块SSD硬盘，对应<code>sda</code>设备是不支持Trim的，但是<code>mmcblk1</code>这个设备，也就是装系统用的一个小的MicroSD卡是支持的。</p><p>那么问题来了，针对上面的输出，sda这块盘是不支持Trim的，那怎么样才能让他支持呢？</p><p>首先需要明确的是，因为这块盘是我通过一块USB移动硬盘盒转接到板子上的，也就意味着这块硬盘并没有用原生的SATA接口（当然这块开发版本身也不支持SATA接口）。而对于移动硬盘盒而言，将SATA口转换成USB口，会需要一个桥接芯片进行协议的转换，那么桥接芯片是否支持Trim命令的转换，就显得非常重要了。对于一些老的移动硬盘盒，大多使用的是Mass Storage Class Bulk-Only Transport (BOT)这个协议，但是对于一些比较新的桥接芯片，基本都会支持一个新的叫做USB Attached SCSI Protocol (UASP) 的新协议。所以我也查了一些资料，同样也是结合产品页的一些宣传，买了一个支持UAS协议的移动硬盘盒，根据评论看，这个硬盘盒是支持Trim的，但是大部分用户似乎都是在Windows下进行测试的，在Linux下是否真的支持，是否需要新版本内核或者驱动的支持还不知道。</p><p>等硬盘盒到手，插上之后系统lsusb看了一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jetson-nano:~:% lsusbBus 002 Device 002: ID 174c:225c ASMedia Technology Inc. Ugreen Storage Device<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>VendorId是0x174c，也就是ASMedia公司的桥接芯片，但是225c这个ProductId并没有在USB ID数据库里查到，不过从数据库里看0x1153这个ProductId对应ASM1153这款芯片来说，那225c应该是对应着ASM225CM这个芯片？从目前的资料看，这个芯片理论上是支持Trim的，至少可以通过刷新固件来解决支持的问题。</p><p>然而系统识别出sda之后，<code>lsblk --discard</code>依然提示不支持Trim。</p><p>于是又搜索了一些资料，终于在<a href="https://wiki.archlinux.org/title/Solid_state_drive#External_SSD_with_TRIM_support">Arch的SSD Wiki</a>里找到了一些信息：</p><blockquote><p>其实现在一些USB转SATA芯片（如VL715、VL716等）以及在外接NVMe硬盘盒（如IB-1817M-C31）中使用的USB转PCIe芯片（如 智微（JMicron） JMS583 ）支持类似TRIM的命令。这些命令可通过 USB Attached SCSI 驱动程序（在Linux下称为”uas”）发送。然而内核可能不会自动检测到并启用这一功能。</p></blockquote><p>会不会是因为芯片是支持的，但是系统默认没有开启呢？于是按Wiki里的说法，使用<code>sg_readcap -l /dev/sda</code>命令读取设备的标志位：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jetson-nano:chenfu:<span class="token comment"># sg_readcap -l /dev/sda</span>Read Capacity results:   Protection: <span class="token assign-left variable">prot_en</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">p_type</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">p_i_exponent</span><span class="token operator">=</span><span class="token number">0</span>   Logical block provisioning: <span class="token assign-left variable">lbpme</span><span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">lbprz</span><span class="token operator">=</span><span class="token number">0</span>   Last <span class="token assign-left variable">LBA</span><span class="token operator">=</span><span class="token number">937703087</span> <span class="token punctuation">(</span>0x37e436af<span class="token punctuation">)</span>, Number of logical <span class="token assign-left variable">blocks</span><span class="token operator">=</span><span class="token number">937703088</span>   Logical block <span class="token assign-left variable">length</span><span class="token operator">=</span><span class="token number">512</span> bytes   Logical blocks per physical block <span class="token assign-left variable">exponent</span><span class="token operator">=</span><span class="token number">0</span>   Lowest aligned <span class="token assign-left variable">LBA</span><span class="token operator">=</span><span class="token number">0</span>Hence:   Device size: <span class="token number">480103981056</span> bytes, <span class="token number">457862.8</span> MiB, <span class="token number">480.10</span> GB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现<code>Logical block provisioning: lbpme=0, lbprz=0</code>其中lbpme&#x3D;0，因为LBPME位为0，所以内核默认是不会开启DISCARD的支持。针对这种情况，还需要继续通过<code>sg_vpd -a /dev/sda</code>命令查询设备支持的命令情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jetson-nano:chenfu:<span class="token comment"># sg_vpd -a /dev/sda</span>Supported VPD pages VPD page:  <span class="token punctuation">..</span>.Unit serial number VPD page:  Unit serial number: 704108E11D02Device Identification VPD page:  Addressed logical unit:    designator type: NAA,  code set: Binary      0x5000000000000001Block limits VPD page <span class="token punctuation">(</span>SBC<span class="token punctuation">)</span>:  Write same non-zero <span class="token punctuation">(</span>WSNZ<span class="token punctuation">)</span>: <span class="token number">0</span>  <span class="token punctuation">..</span>.Block device characteristics VPD page <span class="token punctuation">(</span>SBC<span class="token punctuation">)</span>:  Non-rotating medium <span class="token punctuation">(</span>e.g. solid state<span class="token punctuation">)</span>  <span class="token punctuation">..</span>.Logical block provisioning VPD page <span class="token punctuation">(</span>SBC<span class="token punctuation">)</span>:  Unmap <span class="token builtin class-name">command</span> supported <span class="token punctuation">(</span>LBPU<span class="token punctuation">)</span>: <span class="token number">1</span>  Write same <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> with unmap bit supported <span class="token punctuation">(</span>LBPWS<span class="token punctuation">)</span>: <span class="token number">0</span>  Write same <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> with unmap bit supported <span class="token punctuation">(</span>LBPWS10<span class="token punctuation">)</span>: <span class="token number">0</span>  Logical block provisioning <span class="token builtin class-name">read</span> zeros <span class="token punctuation">(</span>LBPRZ<span class="token punctuation">)</span>: <span class="token number">0</span>  Anchored LBAs supported <span class="token punctuation">(</span>ANC_SUP<span class="token punctuation">)</span>: <span class="token number">0</span>  Threshold exponent: <span class="token number">0</span> <span class="token punctuation">[</span>threshold sets not supported<span class="token punctuation">]</span>  Descriptor present <span class="token punctuation">(</span>DP<span class="token punctuation">)</span>: <span class="token number">0</span>  Minimum percentage: <span class="token number">0</span> <span class="token punctuation">[</span>not reported<span class="token punctuation">]</span>  Provisioning type: <span class="token number">0</span> <span class="token punctuation">(</span>not known or fully provisioned<span class="token punctuation">)</span>  Threshold percentage: <span class="token number">0</span> <span class="token punctuation">[</span>percentages not supported<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现在<code>Logical block provisioning VPD page (SBC)</code>段下，有<code>Unmap command supported (LBPU): 1</code>，说明设备本身是支持Unmap指令的，因为前面说到，ATA中的Trim其实就是对应的SCSI中的UNMAP，所以支持UNMAP也就是支持了Trim，当然这中间的转换过程，应该是有硬盘盒的主控来完成。</p><p>那既然在物理上是支持Trim的，那剩下的就是逻辑上怎么启用的问题了，先看下目前内核识别的设备的provisioning_mode：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jetson-nano:chenfu:<span class="token comment"># cat /sys/block/sda/device/scsi_disk/0:0:0:0/provisioning_mode</span>full<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以发现输出是<code>full</code>，也就是说内核当前是没有检测到设备支持Trim特性，解决方法也比较简单，直接<code>echo unmap</code>到这个文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jetson-nano:chenfu:<span class="token comment"># echo unmap > /sys/block/sda/device/scsi_disk/0:0:0:0/provisioning_mode</span>jetson-nano:chenfu:<span class="token comment"># lsblk --discard</span>NAME        DISC-ALN DISC-GRAN DISC-MAX DISC-ZEROsda                <span class="token number">0</span>      512B       4G         <span class="token number">0</span>mmcblk1            <span class="token number">0</span>        4M      76M         <span class="token number">0</span>└─mmcblk1p1        <span class="token number">0</span>        4M      76M         <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，强制指定provisioning_mode为unmap之后，<code>lsblk --discard</code>的输出已经提示sda设备支持Trim了。</p><p>最后，为了能让这个特性可以在插入硬盘盒的时候自动生效，可以手动编写一个Udev的规则文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'ACTION=="add|change", ATTRS&#123;idVendor&#125;=="174c", ATTRS&#123;idProduct&#125;=="225c", SUBSYSTEM=="scsi_disk", ATTR&#123;provisioning_mode&#125;="unmap"'</span> <span class="token operator">>></span>/etc/udev/rules.d/10-uas-discard.rules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是说，当有idVendor为174c，idProduct为225c的设备（也就是我的这个硬盘盒）连接的时候，自动设置provisioning_mode为unmap。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近折腾了一小段时间的PCDN，家里刚好有一个闲置的JetsonNano和一块闲置的SSD，刚好可以跑跑PCDN，每天挣个宽带钱。具体跑的哪家，就不说了，说说在这过程中遇到的一个小问题：一般来说，PCDN或者类似的业务，对磁盘的写入压力还是比较大的，虽然可能平均的写入带宽并不高，但是也架不住每天读写的时间相当长，虽然我这块SSD是闲置的，但好歹是个传家宝，不管怎么说，还是有那么点点心疼的，肯定是不太希望哪天这SSD被写坏了。&lt;/p&gt;
&lt;p&gt;在这种场景下，尽可能延长SSD的写入寿命就很重要了，而方法之一呢，就是想办法把SSD的&lt;code&gt;Trim&lt;/code&gt;命令给用上。&lt;/p&gt;
&lt;p&gt;用上&lt;code&gt;Trim&lt;/code&gt;命令之前，可以先简单了解一下背后的逻辑，具体的可以参考&lt;a href=&quot;https://zh.wikipedia.org/wiki/Trim%E5%91%BD%E4%BB%A4&quot;&gt;Wiki&lt;/a&gt;，简单来说呢，因为SSD依赖垃圾回收机制来平衡NAND的磨损，但是呢具体到一整个LBA空间，只有文件系统知道哪些数据块是有效数据，所以就需要通过&lt;code&gt;Trim&lt;/code&gt;命令，建立文件系统空闲空间和SSD底层数据块的关联，从而让SSD的主控更好的进行垃圾回收操作，一般来说，合理的使用Trim，可以有效的提高SSD的性能和寿命。当然了，&lt;code&gt;Trim&lt;/code&gt;命令是ATA指令集里的，也就是SATA接口SSD才会有，对于SCSI以及SAS接口SSD，还有NVMe SSD来说，也有相应的&lt;code&gt;UNMAP&lt;/code&gt;和&lt;code&gt;Deallocate&lt;/code&gt;指令，作用都是一样的。&lt;/p&gt;
&lt;p&gt;一般来说，在Linux下，一个设备是否支持&lt;code&gt;Trim&lt;/code&gt;操作，可以通过&lt;code&gt;lsblk --discard&lt;/code&gt;进行查看，当输出中的&lt;code&gt;DISC-GRAN&lt;/code&gt;和&lt;code&gt;DISC-MAX&lt;/code&gt;列不为0时，说明这个设备是支持&lt;code&gt;Trim&lt;/code&gt;操作的：&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="SSD" scheme="https://www.ichenfu.com/tags/SSD/"/>
    
    <category term="Trim" scheme="https://www.ichenfu.com/tags/Trim/"/>
    
    <category term="UAS" scheme="https://www.ichenfu.com/tags/UAS/"/>
    
  </entry>
  
  <entry>
    <title>SPDK的“Reduce”块压缩算法</title>
    <link href="https://www.ichenfu.com/2022/04/05/spdk-reduce-block-compression-algorithm/"/>
    <id>https://www.ichenfu.com/2022/04/05/spdk-reduce-block-compression-algorithm/</id>
    <published>2022-04-05T13:03:28.000Z</published>
    <updated>2022-04-28T05:53:29.134Z</updated>
    
    <content type="html"><![CDATA[<p>本文是SPDK文档<a href="https://spdk.io/doc/reduce.html">SPDK “Reduce” Block Compression Algorithm</a>的翻译，在读SPDK的文档过程中，刚好看到了SPDK里<code>bdev reduce</code>模块实现背后的算法描述，于是就想着翻译一下，正好也借翻译的同时仔细理解一下背后算法的原理，当然本人的水平有限，如果译文有任何歧义，还请参考原文并以实际原文为准。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SPDK的“reduce”块压缩方案使用SSD存储压缩后的块数据，同时将元数据存放到持久内存中。此元数据包含用户数据的逻辑块到压缩后的物理块的对应关系。本文档中描述的方案是通用的，不依赖于包括<code>SPDK</code>在内任何特定的块设备框架。该算法会在一个叫做<code>libreduce</code>的库中实现。更高层次的软件可以基于该模块创建和呈现特定的块设备。对于SPDK来说，<code>bdev_reduce</code>模块封装了<code>libreduce</code>库，从而在SPDK中提供一个bdev以实现压缩功能。</p><p>本方案仅仅解释压缩后的数据块和用于跟踪这些数据块的元数据的管理。它依赖于高层软件模块来执行压缩操作。对于SPDK，<code>bdev_reduce</code>模块利用<code>DPDK compressdev</code>框架执行压缩和解压缩。</p><p>（需要注意的是，在某些情况下，数据块可能是不可压缩的，或者无法压缩到足以实现空间节省的程度。在这些情况下，数据可能不经过压缩，直接存储在磁盘上。“压缩的存储块”包括这些不经压缩的块。）</p><span id="more"></span><p>一个压缩块存储设备是一个建立在拥有相似大小的后备存储设备之上的一个逻辑实体。其中的后备存储设备必须是精简置备（thin-provisioned）的从而才能真正意义上从后文描述的实现中获得空间节省。同样该算法除了一直使用后备存储设备上可用的编号最低的块之外，对后备存储设备的实现没有直接的了解。这保证了在精简配置的后备存储设备上使用此算法时，在实际需要空间之前不会分配对应空间。</p><p>后备存储的大小，必须考虑最坏情况，也就是所有数据都不可压缩的情况。在这种情况下，后备存储的大小和压缩块设备的大小是一致的。另外，本算法基于永远不会原地写这个前台来保证原子性，所以在更新元数据之前，可能还需要额外的一些后备存储空间来作为临时写缓存。</p><p>为了最佳性能考虑，所有后备存储设备都将以4KB为最小单位进行分配、读取和写入。这些4KB的单元被称作“后备IO单元”（backing IO units）。他们被一个称作“后备IO单元索引”（backing IO unit indices）的索引列表中以0到N-1编号进行索引。在一开始，这个完整的索引代表了“空闲后备IO单元列表”（free backing IO unit list）。</p><p>一个压缩块存储设备基于chunk进行压缩和解压操作，chunk大小至少是两个4K的后备IO单元，每个chunk所需要的后备IO单元数量，也同样表明了chunk的大小，这个数量或者大小需要在压缩块存储设备创建时指定。一个chunk，需要消耗至少1个，至多chunk大小个后备IO单元数量。举个例子，一个16KB的chunk，有可能消耗1，2，3，4个后备IO单元，最终消耗的数量取决于这个chunk的压缩率。磁盘blocks和chunk的对应关系，存储在持久内存中的一个<code>chunk map</code>里。每个<code>chunk map</code>包含了N个64-bit的值，其中N是每个chunk所包含的后备IO单元的数量。每个64-bit值表示一个后备IO单元的索引。一个特殊的值（举个例子，2^64-1）用来表示因为压缩节省而不需要使用实际的后备存储。<code>chunk map</code>的数量，等于压缩块设备的容量除以它的chunk大小，再加上少量用于保证原子写操作额外的一些<code>chunk map</code>。一开始所有的<code>chunk map</code>都表示“空闲chunk map列表”。</p><p>最后，压缩块设备的逻辑映射表通过“logical map”进行表示。这里的“logical map”指的是压缩块存储设备对于对于chunk map的偏移的对于关系。logical map里每个条目是一个64-bit的值，表示所关联的chunk map。一个特殊值（UINT64_MAX）表示没有对应关联的chunk map。映射是通过将字节偏移量除以块大小得到一个索引来确定的，该索引用作块映射条目数组的数组索引。 开始时，逻辑映射表中的所有条目都没有关联的块映射。 请注意，虽然对后备存储设备的访问以 4KB 为单位，但逻辑映射表可能允许以4KB或512B为单位进行访问。</p><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>为了说明这个算法，我们将使用一个真实的非常小规模的例子。</p><p>压缩块设备的大小为64KB，chunk大小为16KB。 这会实现以下几点：</p><ul><li>“后备存储” 需要是一个80KB大小的精简置备（thin-provisioned）逻辑设备。这包括了64KB的压缩设备原始大小，以及为了在最坏情况下保证写原子性而额外分配的16KB大小。</li><li>“空闲后备IO单元列表”（free backing IO unit list）由一个0-19的索引组成，这些索引表示在后备存储里的20个4KB最小IO单元。</li><li>一个”chunk map”的大小是32字节， 对应每个chunk需要4个后备存储单元（16KB&#x2F;4KB），以及每个存储单元需要8个字节（64bit）进行表示。</li><li>需要从持久内存中分配5个chunk map，共160B的空间。这包含了压缩块设备的4个chunk（64KB &#x2F; 16KB）所对应的4个chunk map以及为了改写已有chunk时需要的额外1个chunk map</li><li>“空闲后备IO单元列表”（Free chunk map list） 将由0 - 4（包含4）进行索引。 这些索引表示这5个被分配的chunk map</li><li>“逻辑映射表”（logical map）需要在持久内存中分配32B空间，这包含了压缩块设备4个chunk的索引，每个索引需要8B（64bit）。</li></ul><p>在下面的例子中，”X”符号代表上面所说的那个特殊值特殊值（2^64-1）。</p><h3 id="创建初始化（Initial-Creation）"><a href="#创建初始化（Initial-Creation）" class="headerlink" title="创建初始化（Initial Creation）"></a>创建初始化（Initial Creation）</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------------+Backing Device  |                    |                +--------------------+Free Backing IO Unit List  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19           +------------+------------+------------+------------+------------+Chunk Maps |            |            |            |            |            |           +------------+------------+------------+------------+------------+Free Chunk Map List  0, 1, 2, 3, 4            +---+---+---+---+Logical Map | X | X | X | X |            +---+---+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在32KB偏移量处写入16KB（Write-16KB-at-Offset-32KB）"><a href="#在32KB偏移量处写入16KB（Write-16KB-at-Offset-32KB）" class="headerlink" title="在32KB偏移量处写入16KB（Write 16KB at Offset 32KB）"></a>在32KB偏移量处写入16KB（Write 16KB at Offset 32KB）</h3><ul><li>找到逻辑映射表（logical map）对应的index。32KB偏移量除以16KB的chunk size，得到index为2。</li><li>Logical map里的第2个单元是一个“X”，也就是说当前这16KB还没有被写入过。</li><li>在内存中分配16KB的buffer。</li><li>将写入的这16KB数据压缩后，存入到刚刚分配的buffer中。</li><li>假设数据被压缩到只剩6KB，那么就需要2个4KB的后备IO单元。</li><li>从空闲后备IO单元列表中分配2个block（编号0和1）。需要注意的是，永远都从空闲后备IO单元列表中最小的单元还是分配，这样可以保证在thin-provision情况下，不会用到多余的后端存储，从而节省容量。</li><li>将压缩后的6KB数据存储到后备存储的第0和第一个单元。</li><li>从空闲chunk map列表中分配一个chunk map 0。</li><li>将（0，1，X，X）存储到chunk map 0中。这表示只有2个后备IO单元被用来存储这16KB数据。</li><li>把chunk map的编号0，写到逻辑映射表（logical map）的第二个单元中。</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------------+Backing Device  |01                  |                +--------------------+Free Backing IO Unit List  2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19           +------------+------------+------------+------------+------------+Chunk Maps | 0 1 X X    |            |            |            |            |           +------------+------------+------------+------------+------------+Free Chunk Map List  1, 2, 3, 4            +---+---+---+---+Logical Map | X | X | 0 | X |            +---+---+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在8KB偏移量处写入4KB（Write-4KB-at-Offset-8KB）"><a href="#在8KB偏移量处写入4KB（Write-4KB-at-Offset-8KB）" class="headerlink" title="在8KB偏移量处写入4KB（Write 4KB at Offset 8KB）"></a>在8KB偏移量处写入4KB（Write 4KB at Offset 8KB）</h3><ul><li>在逻辑映射表中找到对应的index。 8KB偏移量，除以16KB的chunk size，得到index为0。</li><li>逻辑映射表中的0号条目是“X”，这表示这16KB还没有被写入过数据。</li><li>写入请求不是一个完整的16KB chunk大小，所以我们必须要先分配一个16KB的buffer用于暂存源数据。</li><li>把需要写入的4KB数据写入到这16KB buffer的8KB偏移处，并把buffer其他的地方填0。</li><li>再分配16KB的目标buffer。</li><li>把16KB的源数据，压缩后存入到目标buffer中。</li><li>假设数据被压缩到3KB，这将需要1个4KB的后备IO单元。</li><li>从空闲后备单元列表中分配一个block（编号2）。</li><li>把3KB数据写入到编号2的block中。</li><li>从空闲chunk map列表中分配一个空闲chunk map(编号1)。</li><li>把（2，X，X，X）写入到chunk map中。</li><li>将chunk map的索引（编号1）写入到逻辑映射表的第0个条目里。</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------------+Backing Device  |012                 |                +--------------------+Free Backing IO Unit List  3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19           +------------+------------+------------+------------+------------+Chunk Maps | 0 1 X X    | 2 X X X    |            |            |            |           +------------+------------+------------+------------+------------+Free Chunk Map List  2, 3, 4            +---+---+---+---+Logical Map | 1 | X | 0 | X |            +---+---+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在16K偏移量处读取16KB数据（Read-16KB-at-Offset-16KB）"><a href="#在16K偏移量处读取16KB数据（Read-16KB-at-Offset-16KB）" class="headerlink" title="在16K偏移量处读取16KB数据（Read 16KB at Offset 16KB）"></a>在16K偏移量处读取16KB数据（Read 16KB at Offset 16KB）</h3><ul><li>16KB偏移量，在逻辑映射表中对应第1个条目。</li><li>逻辑映射表第1个条目是“X”，这说明这个16KB空间还没有被写入过任何数据。</li><li>由于这16KB的chunk还没有被写入过任何数据，所以直接这个读请求直接返回全0。</li></ul><h3 id="在4KB偏移量处写入4KB（Write-4KB-at-Offset-4KB）"><a href="#在4KB偏移量处写入4KB（Write-4KB-at-Offset-4KB）" class="headerlink" title="在4KB偏移量处写入4KB（Write 4KB at Offset 4KB）"></a>在4KB偏移量处写入4KB（Write 4KB at Offset 4KB）</h3><ul><li>4KB偏移量，在逻辑映射表中对应第0个条目。</li><li>逻辑映射表的第0个条目是“1”，由于我们并不是覆盖写整个chunk，所以我们必须要进行一个读-改-写（read-modify-write）操作。</li><li>chunk map 1仅仅指定了一个后备IO单元（编号2），分配一个16KB的buffer，并讲编号2的后备IO单元读入到这个buffer，这个buffer后面会被叫做压缩数据buffer。<br>需要注意的是，因为我们一下子分配了16KB的buffer而不是只分配4KB，我们可以继续使用这个buffer作为后面新压缩数据的存放地点。</li><li>再分配一个16KB的buffer用于存放解压后的数据。解压压缩数据buffer里的数据，并将数据存入刚分配的buffer里。</li><li>把需要写入的4KB数据写入到解压数据buffer的4KB偏移处。</li><li>把解压数据buffer里的数据压缩，并放到压缩数据buffer中。</li><li>假设新的数据压缩后大小5KB，这将需要2个4KB的后备IO单元。</li><li>从空闲后备IO单元列表里，分配编号为3和4的两个block。</li><li>将这个5KB数据写入到3和4这两个block中。</li><li>从空闲chunk map列表中分配编号2的chunk map。</li><li>将（3，4，X，X）写入到编号2的chunk map中。需要注意的是，到当前节点，这个chunk map还没有被逻辑映射表引用，如果此时出现了掉电，当前chunk的数据依然是保持完整的。</li><li>将chunk map的编号2写入到逻辑映射表中。</li><li>释放编号为1的chunk map，并放入到空闲chunk map列表中。</li><li>释放编号为2的后备IO单元，并将编号放入到空闲后备IO单元列表中。</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">                +--------------------+Backing Device  |01 34               |                +--------------------+Free Backing IO Unit List  2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19           +------------+------------+------------+------------+------------+Chunk Maps | 0 1 X X    |            | 3 4 X X    |            |            |           +------------+------------+------------+------------+------------+Free Chunk Map List  1, 3, 4            +---+---+---+---+Logical Map | 2 | X | 0 | X |            +---+---+---+---+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="跨越多个chunks的请求（Operations-that-span-across-multiple-chunks）"><a href="#跨越多个chunks的请求（Operations-that-span-across-multiple-chunks）" class="headerlink" title="跨越多个chunks的请求（Operations that span across multiple chunks）"></a>跨越多个chunks的请求（Operations that span across multiple chunks）</h3><p>针对跨越多个chunks的请求，逻辑上这个请求会被分割成多个请求，每个请求关联一个chunk。</p><p>举例：在4KB偏移处写入20KB数据</p><p>在这个场景下，这个写请求会被分割成：一个在4KB偏移处写入12KB数据的请求（只影响逻辑映射表的第0个条目），以及一个在偏移量16KB处写入8KB的请求（只影响逻辑映射表的第1个条目）。<br>每个子请求都独立的基于上述的算法进行处理，直到这两个子请求全部完成时，原始的20KB写入操作才会返回。</p><h3 id="Unmap操作（Unmap-Operations）"><a href="#Unmap操作（Unmap-Operations）" class="headerlink" title="Unmap操作（Unmap Operations）"></a>Unmap操作（Unmap Operations）</h3><p>Unmap操作通过从逻辑映射表中删除对应的（如果有）chunk map条目来实现，对应的chunk map会被放回到空闲chunk map列表中，并且任何相关的后备IO单元也会被释放并放回到空闲后备IO单元列表中。</p><p>而对于针对chunk的某一部分进行Unmap的操作，相当于对chunk的这一部分写0，如果整个chunk在多次的操作中被整体Unmap掉了，那么未压缩的数据就变成全0了，这样就可以被检测出来，在这种情况下，整个chunk的映射条目也会从逻辑映射表里被移除。</p><p>当整个chunk都被Umap掉之后，后续针对该chunk的读操作都会返回全0，这个表现就和上述在16K偏移量处读取16KB数据（Read 16KB at Offset 16KB）的例子一致。</p><h3 id="写0操作（Write-Zeroes-Operations）"><a href="#写0操作（Write-Zeroes-Operations）" class="headerlink" title="写0操作（Write Zeroes Operations）"></a>写0操作（Write Zeroes Operations）</h3><p>写0操作的流程和Unmap操作类似，如果一个写0操作覆盖了整个chunk，我们也可以在逻辑映射表中完全移除整个chunk的对应条目，然后后续的读操作也会返回全0。</p><h3 id="Restart"><a href="#Restart" class="headerlink" title="Restart"></a>Restart</h3><p>一个使用<code>libreduce</code>模块的应用程序，有可能需要定期退出并重新启动。当应用程序重新启动的时候，会重新加载压缩卷，从而恢复到应用程序退出之前的状态。</p><p>当压缩卷被加载的时候，空闲chunk map列表和空闲后备IO单元列表会通过扫描逻辑映射表的形式进行重建。逻辑映射表只会保存有效的chunk map索引，同样的，chunk map只会保存有效后备单元索引。<br>任何没有被引用的chunk map以及后备IO单元，都会被认为是空的，并加入到对应的空闲列表中。</p><p>这就保证了如果系统在一个写操作的中间状态下崩溃后（比如在chunk map被更新，但还没写入逻辑映射表的过程中崩溃）重启的过程中，所有未完成的写入操作都会被忽略。</p><h3 id="对同一个chunk的并发操作（Overlapping-operations-on-same-chunk）"><a href="#对同一个chunk的并发操作（Overlapping-operations-on-same-chunk）" class="headerlink" title="对同一个chunk的并发操作（Overlapping operations on same chunk）"></a>对同一个chunk的并发操作（Overlapping operations on same chunk）</h3><p>具体实现时，必须要考虑针对同一个chunk并发操作的情况。比如第一个IO需要对chunk A写入某些数据，同时又有第二个IO也需要对chunk A进行写入。在这种情况下，第二个IO必须等第一个IO完成之后才能开始。<br>针对类似情况的进一步优化，超出了本文档的描述范围。</p><h3 id="精简置备的后备存储（Thin-provisioned-backing-storage）"><a href="#精简置备的后备存储（Thin-provisioned-backing-storage）" class="headerlink" title="精简置备的后备存储（Thin provisioned backing storage）"></a>精简置备的后备存储（Thin provisioned backing storage）</h3><p>后备存储设备必须是精简置备的，从而才能在压缩场景下实现空间节约。本文的算法永远都会使用（重用）后备存储上最靠近偏移量0的后备IO单元。<br>这确保了即使后备存储的空间和压缩块设备的大小接近，但是直到确实需要后备IO单元的时候，才会真正从后备存储设备上分配存储空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是SPDK文档&lt;a href=&quot;https://spdk.io/doc/reduce.html&quot;&gt;SPDK “Reduce” Block Compression Algorithm&lt;/a&gt;的翻译，在读SPDK的文档过程中，刚好看到了SPDK里&lt;code&gt;bdev reduce&lt;/code&gt;模块实现背后的算法描述，于是就想着翻译一下，正好也借翻译的同时仔细理解一下背后算法的原理，当然本人的水平有限，如果译文有任何歧义，还请参考原文并以实际原文为准。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SPDK的“reduce”块压缩方案使用SSD存储压缩后的块数据，同时将元数据存放到持久内存中。此元数据包含用户数据的逻辑块到压缩后的物理块的对应关系。本文档中描述的方案是通用的，不依赖于包括&lt;code&gt;SPDK&lt;/code&gt;在内任何特定的块设备框架。该算法会在一个叫做&lt;code&gt;libreduce&lt;/code&gt;的库中实现。更高层次的软件可以基于该模块创建和呈现特定的块设备。对于SPDK来说，&lt;code&gt;bdev_reduce&lt;/code&gt;模块封装了&lt;code&gt;libreduce&lt;/code&gt;库，从而在SPDK中提供一个bdev以实现压缩功能。&lt;/p&gt;
&lt;p&gt;本方案仅仅解释压缩后的数据块和用于跟踪这些数据块的元数据的管理。它依赖于高层软件模块来执行压缩操作。对于SPDK，&lt;code&gt;bdev_reduce&lt;/code&gt;模块利用&lt;code&gt;DPDK compressdev&lt;/code&gt;框架执行压缩和解压缩。&lt;/p&gt;
&lt;p&gt;（需要注意的是，在某些情况下，数据块可能是不可压缩的，或者无法压缩到足以实现空间节省的程度。在这些情况下，数据可能不经过压缩，直接存储在磁盘上。“压缩的存储块”包括这些不经压缩的块。）&lt;/p&gt;</summary>
    
    
    
    <category term="SPDK" scheme="https://www.ichenfu.com/categories/SPDK/"/>
    
    
    <category term="SPDK" scheme="https://www.ichenfu.com/tags/SPDK/"/>
    
    <category term="Reduce" scheme="https://www.ichenfu.com/tags/Reduce/"/>
    
    <category term="bdev reduce" scheme="https://www.ichenfu.com/tags/bdev-reduce/"/>
    
  </entry>
  
  <entry>
    <title>实现一个Kubernetes的身份认证代理服务</title>
    <link href="https://www.ichenfu.com/2022/03/20/implement-a-k8s-authenticating-proxy/"/>
    <id>https://www.ichenfu.com/2022/03/20/implement-a-k8s-authenticating-proxy/</id>
    <published>2022-03-20T08:41:36.000Z</published>
    <updated>2022-04-28T05:53:29.134Z</updated>
    
    <content type="html"><![CDATA[<p>最近接到一个需求：把K8s的认证和授权体系，整合到我们内部的系统中，使得我们内部系统的用户，可以无缝的直接访问K8s集群，同时也需要限制好用户对应namespace的权限。</p><p>对于需求的用户授权也就是authorization (authz)部分，实现思路还是比较简单的，毕竟K8s的<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/">RBAC</a>实现相对来说还是非常完善的，而且RBAC对于我们目前的用户和组织权限管理理念十分的接近。所以只需要将目前系统里的用户权限和组织关系，对应到一系列的RBAC Role和RoleBinding里，就可以实现对于用户权限的精细化控制。</p><p>而对于用户的认证authentication (authn)部分，K8s提供了非常多的<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/authentication/">身份认证策略</a>。但是如文档里明确的一点：</p><span id="more"></span><blockquote><p>Kubernetes 假定普通用户是由一个与集群无关的服务通过以下方式之一进行管理的：</p><ul><li>负责分发私钥的管理员</li><li>类似 Keystone 或者 Google Accounts 这类用户数据库</li><li>包含用户名和密码列表的文件<br>有鉴于此，Kubernetes 并不包含用来代表普通用户账号的对象。 普通用户的信息无法通过API调用添加到集群中。</li></ul></blockquote><p>K8s并不自己管理用户实体，所以是没有办法像RBAC那样，通过创建一个“User”资源，来把某个用户添加到集群里的。</p><p>其实这个特点，对于系统集成来说，可能更是一个优点，因为这直接避免了第三方系统的用户属性和K8s“用户”属性可能存在的不兼容问题。</p><p>而对于目前的需求而言，需要做到以下几点：</p><ol><li>最好是基于Token实现，并且这个Token由我们自己的系统生成，同一个Token，既可以调用原有的API，也可以调用K8s的API。</li><li>尽可能保证K8s兼容性，最好用户可以无缝的，不需要经过复杂的配置，直接使用kubectl访问到集群。</li><li>记录所有用户的访问记录以便于各种审计工作。</li></ol><p>针对这几个需求，又通读了一遍文档之后，最终决定使用<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/authentication/#authenticating-proxy">身份认证代理</a>这个方式，怎么理解呢：</p><p>K8s APIServer可以获取HTTP请求中的某些头部字段，根据头部字段的值来判断当前操作的用户。也就是说，如果实现一个反向代理服务器，由这个反向代理服务器实现Token的认证工作，确认用户请求的有效性，若用户请求有效，直接把用户的信息添加到HTTP请求头中，并代理到K8s Server，最终再由K8s中的RBAC规则，判断用户能否调用对应API。</p><p>这么做刚好能满足目前的需求，首先，Token的发放和验证完全和K8s没有关系，所以Token可以保持和原有系统保持不变；同样的，代理只是根据HTTP头进行验证并转发，也不会修改任何K8s API的调用方式和格式，所以也能保持很好的兼容性；又因为所有的用户请求都会经过代理服务器，所以代理服务器可以记录所有请求的详细信息，从而方便实现各种审计工作。</p><p>那么问题来了，K8s通过哪个HTTP Header获取用户信息呢？</p><p>APIServer提供了几个命令行参数：<code>--requestheader-username-headers</code>、<code>--requestheader-group-headers</code>、<code>--requestheader-extra-headers-prefix</code>，通过这几个参数来配置HTTP头的字段名称。<br>其中，只有<code>--requestheader-username-headers</code>这个参数是必须的，由于目前场景下只需要配置这一个参数就可以了。比如：添加<code>--requestheader-username-headers=X-Remote-User</code>到APIServer启动参数，APIServer就会从请求中获取X-Remote-User这个头，并用对应的值作为当前操作的用户。</p><p>事情还没有结束，既然APIServer会从请求头中获取用户名，那么问题来了，如何确保这个请求是可信的？如何防止恶意用户，伪造请求，绕过身份认证代理服务器，直接用假冒的请求访问APIServer怎么办？这样是不是就可以模拟任何用户访问了？那一定不行，得需要有个办法来验证代理服务器的身份。不过K8s的开发者们显然考虑到了这个问题，所以APIServer提供了<code>--requestheader-client-ca-file</code>和<code>--requestheader-allowed-names</code>两个额外的参数，其中<code>--requestheader-client-ca-file</code>是必须的，用来指定认证代理服务器证书的CA位置，如果同时指定<code>--requestheader-allowed-names</code>，则在验证客户端证书发行者的同时，还会验证客户端证书的CN字段，确保不会有人用其他证书模仿代理服务器。</p><p>说到这里，整个解决方案的思路就已经比较清楚了：1.让用户带上token访问身份代理服务器；2.身份代理服务器解析token，确认用户身份后将用户名带入到请求X-Remote-User头，并转发给K8s，这里需要注意带上预先签好的客户端证书访问；3.K8s通过请求头部信息确认用户，并基于RBAC规则确认用户权限。</p><p>针对上面的方案，这里简单的使用openresty搭建了一个测试方案，主要也是因为目前的Token是jwt格式的，解析和验证也比较方便，这里贴一个比较简单的配置例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen       <span class="token number">80</span><span class="token punctuation">;</span>server_name  test.k8sproxy.ichenfu.com<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span>access_by_lua <span class="token string">'-- 因为token格式是jwt，且用户名是在jwt payload里的，所以需要依赖resty.jwt这个库-- 具体的安装方式这里不详细说明，可以查找其他资料local cjson = require("cjson")local jwt = require("resty.jwt")-- 拿到用户请求的Authorization头local auth_header = ngx.var.http_Authorizationif auth_header == nil then-- 禁止没有认证信息的请求ngx.exit(ngx.HTTP_UNAUTHORIZED)endlocal _, _, jwt_token = string.find(auth_header, "Bearer%s+(.+)")if jwt_token == nil then-- 禁止认证信息有误的请求ngx.exit(ngx.HTTP_UNAUTHORIZED)end-- secret，需要保密！local secret = "ichenfu-jwt-secret"local jwt_obj = jwt:verify(secret, jwt_token)if jwt_obj.verified == false then-- 如果验证失败，说明Token有问题，禁止ngx.exit(ngx.HTTP_UNAUTHORIZED)else-- 验证成功，设置X-Remote-User头为用户名（假设用户名存储在payload中的user字段）ngx.req.set_header("X-Remote-User", jwt_obj.user)end'</span><span class="token punctuation">;</span>proxy_ssl_certificate /usr/local/openresty/nginx/conf/ssl/auth-proxy.pem<span class="token punctuation">;</span>proxy_ssl_certificate_key /usr/local/openresty/nginx/conf/ssl/auth-proxy-key.pem<span class="token punctuation">;</span>proxy_pass https://test.k8scluster.ichenfu.com:6443<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说起来openresty确实很方便，十几行代码就搞定了一个K8s的认证代理服务器。不过在后续测试过程中，遇到了一个问题。基于上面的逻辑，用户可以拿着Token，使用kubectl访问集群，但是在实际测试过程中，发现即使在kubeconfig文件中添加了Token，甚至使用<code>kubectl --token=&quot;xxxxxxxxx&quot; get pods</code>这种在命令行里，指定Token的方式，都会提示请求失败，找不到认证信息。一开始，以为是自己lua程序写的有问题，最后通过<code>kubectl --token=&quot;xxxxxxxxx&quot; get pods --v=10 2&gt;&amp;1</code>把请求过程打印出来才发现，kubectl根本不会把Token带入到请求头中！</p><p>经过一番查找，找到了<a href="https://github.com/kubernetes/kubectl/issues/744">kubectl does not send Authorization header (or use specified auth plugin) over plain HTTP #744</a>这个Issue。才发现原来kubectl在默认情况下，如果访问一个HTTP协议的API地址，就认为这个服务是不需要认证的，如果需要认证，那API地址必须是HTTPS协议。</p><p>所以，为了实现预期的结果，还需要修改一下nginx配置文件，把监听换成HTTPS：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen       <span class="token number">443</span> ssl<span class="token punctuation">;</span>server_name  test.k8sproxy.ichenfu.com<span class="token punctuation">;</span>ssl_certificate      /usr/local/openresty/nginx/conf/ssl/kubernetes.pem<span class="token punctuation">;</span>ssl_certificate_key  /usr/local/openresty/nginx/conf/ssl/kubernetes-key.pem<span class="token punctuation">;</span><span class="token comment">#localtion配置保持不变</span><span class="token comment">#...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终，所有需求都完美实现！当然需求的实现方式肯定不止这一种，而且最终即使使用这种方式，可能也不太会选择openresty，但是整体实现和测试的过程还是非常有意思的，特别是“意外”地知道了kubectl对于服务器认证的相关处理，收获还是不少的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接到一个需求：把K8s的认证和授权体系，整合到我们内部的系统中，使得我们内部系统的用户，可以无缝的直接访问K8s集群，同时也需要限制好用户对应namespace的权限。&lt;/p&gt;
&lt;p&gt;对于需求的用户授权也就是authorization (authz)部分，实现思路还是比较简单的，毕竟K8s的&lt;a href=&quot;https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/&quot;&gt;RBAC&lt;/a&gt;实现相对来说还是非常完善的，而且RBAC对于我们目前的用户和组织权限管理理念十分的接近。所以只需要将目前系统里的用户权限和组织关系，对应到一系列的RBAC Role和RoleBinding里，就可以实现对于用户权限的精细化控制。&lt;/p&gt;
&lt;p&gt;而对于用户的认证authentication (authn)部分，K8s提供了非常多的&lt;a href=&quot;https://kubernetes.io/zh/docs/reference/access-authn-authz/authentication/&quot;&gt;身份认证策略&lt;/a&gt;。但是如文档里明确的一点：&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://www.ichenfu.com/categories/Kubernetes/"/>
    
    
    <category term="authenticating-proxy" scheme="https://www.ichenfu.com/tags/authenticating-proxy/"/>
    
    <category term="kubectl token" scheme="https://www.ichenfu.com/tags/kubectl-token/"/>
    
    <category term="RBAC" scheme="https://www.ichenfu.com/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>使用Go-Ceph库编写一个更简单的RBD HTTP API</title>
    <link href="https://www.ichenfu.com/2022/03/05/build-a-ceph-rbd-http-api-with-go-ceph/"/>
    <id>https://www.ichenfu.com/2022/03/05/build-a-ceph-rbd-http-api-with-go-ceph/</id>
    <published>2022-03-05T14:27:13.000Z</published>
    <updated>2022-03-14T01:46:02.155Z</updated>
    
    <content type="html"><![CDATA[<p>很多人看到这个标题会很奇怪，Ceph不是有一个<a href="https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html">RESTful API</a>么，为什么又要造一遍轮子？</p><p>的确，Ceph的官方组件Dashboard，内置了一些非常强大的RESTful API，功能也是比较的全面。为啥又要自己写一个呢？在我们的环境里，有一个自己实现的类似Openstack的虚拟机管理平台。而这个平台对接Ceph RBD时，就是使用的Dashboard模块提供的API。个人觉得啊，官方的API，虽然功能全，但确实对于对接的用户来说，真的不是那么友好。这里举几个简单的点：</p><span id="more"></span><ol><li><p>官方API基于Token进行鉴权，而Token又通过用户名和密码进行获取，并且有一个固定的过期时间，这就会有两个选择，一个暴力点的选择是不管发送什么请求，都会获取一个新的Token，这样可以保证基于新Token的请求都可以成功；或者，每次在请求之前请求<a href="https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html#post--api-auth-check">auth&#x2F;check</a>接口，确认Token的有效性，如果失效了，那就重新获取；再或者，根据请求的返回值，如果出现401错误等等情况，再重新获取新的Token。但是无论是哪种方法，都会显得冗余和逻辑复杂，特别是在多线程等等环境下，还需要考虑使用单例等等。另外，这多出来的这些Token请求，确实也拖慢了整体的效率，毕竟Python写的API，确实不算快。</p></li><li><p>官方API是一个异步API，怎么理解呢？让我们先看下大部分接口的返回值，以<a href="https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html#post--api-block-image">创建RBD</a>为例：</p><blockquote><ul><li>201 Created – Resource created.</li><li>202 Accepted – Operation is still executing. Please check the task queue.</li><li>400 Bad Request – Operation exception. Please check the response body for details.</li><li>401 Unauthorized – Unauthenticated access. Please login first.</li><li>403 Forbidden – Unauthorized access. Please check your permissions.</li><li>500 Internal Server Error – Unexpected error. Please check the response body for the stack trace.</li></ul></blockquote><p>对于一个创建请求，如果成功，则可能会有两种返回值：201表示RBD Image创建成功，可以直接使用；202表示创建任务已经被接受了，但是还没有创建成功，具体的结果，需要去队列里找结果。怎么理解呢？如果返回201，那么恭喜，这个Image可以直接被使用了。如果返回了202，那此时还不能直接使用这个Image，因为仅仅是添加了任务，必须等任务执行完成之后，Image才真正可用。那怎么去寻找这个任务结果呢？又需要我们去轮询调用<a href="https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html#get--api-task">Display Tasks API</a>，然后从返回的一个列表里，自己匹配刚刚的请求，来确认什么时间任务被执行完成。这个动作实在是不太优雅，让人难受。</p></li><li><p>官方API确实也缺失了一些功能。因为我们是一个VM的环境，依赖Clone功能实现VM的OS卷分发，而Clone功能又依赖某个Image的某个Snapshot。但是翻遍了<a href="https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html#rbdsnapshot">RBDSNAPSHOT</a>章节的文档，也没有找到如何确认某个Image的某个名字Snapshot是否存在的接口，最后从<a href="https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html#get--api-block-image-image_spec">获取Image详情API</a>的返回结果里找到了Image所拥有的Snapshot列表。但是呢，除了Snapshot，这个接口也会返回所有基于该Snapshot创建的所有Clone的列表。如果像我们现在这样某个Snapshot会有成千上万个Clone（有很多VM的操作系统都是一样的）。那这个接口的返回Body就会变得无比之大，这对于Dashboard、以及客户端的解析，都会是一个不小的成本。</p></li></ol><p>当然了，这些问题，也只是在我们这个特定环境下的痛点，是绝对不可以说Ceph本身的实现问题的，那这些问题，要么忍着，要么，也可以尝试改变一下。</p><p>要说到同样是一个虚拟机管理平台，Openstack是怎么面临这些问题的呢？是不是我们也可以参考一下Openstack的实现呢？很遗憾，在Openstack Cinder组件里，是直接通过librbd的Python binding实现的。可惜的是我们并没有使用Python进行开发，相对于Openstack来说，集成方式也有些区别。</p><p>不过好在Ceph官方也提供了librbd的Golang Binding<a href="https://github.com/ceph/go-ceph">go-ceph</a>，原理和Python一样，也是直接基于librbd的C接口，那既然这样，我们也可以尝试基于这个库，实现一个我们自己的RBD HTTP API。不需要多么花哨的设计和功能，只需要满足最基本的功能就可以了。</p><p>实现之前，还是先整理一下我们的需求。到目前为止，需求并不复杂，当然未来可能会对接K8S或者类似的容器平台，还需要额外的其他接口，但在当前虚拟机这个场景下，我们需要的功能如下：</p><pre><code>1. Image相关接口，包括创建Image，获取Image信息，扩容Image，设置Image QOS，删除Image2. Snapshot相关接口，包括针对Image创建Snapshot，根据Snapshot创建Clone，以及判断Image某个Snapshot是否存在（这个接口在上面提到官方API没有，但是librbd里是有相关接口的）</code></pre><p>看起来还是比较简单的，这里举个创建Image接口的例子，顺便也算是提供了一个简单的go-ceph的使用文档，在这之前，go-ceph相关的文档确实不太好找，以至于我只能一遍看他的实现代码，一边看librbd的文档写代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"github.com/ceph/go-ceph/rados"</span><span class="token string">"github.com/ceph/go-ceph/rbd"</span><span class="token punctuation">)</span><span class="token keyword">const</span> PoolName <span class="token operator">=</span> <span class="token string">"test_rbd_pool"</span><span class="token keyword">const</span> ImageName <span class="token operator">=</span> <span class="token string">"test-image-name"</span><span class="token keyword">const</span> ImageSize <span class="token builtin">uint64</span> <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token comment">// 100GB</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> rados<span class="token punctuation">.</span><span class="token function">NewConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 打开默认的配置文件（/etc/ceph/ceph.conf）</span><span class="token keyword">if</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">ReadDefaultConfigFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ctx<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">OpenIOContext</span><span class="token punctuation">(</span>PoolName<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">defer</span> ctx<span class="token punctuation">.</span><span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 这里使用默认配置创建，也可以根据自己需求，指定image的features</span><span class="token keyword">if</span> err <span class="token operator">:=</span> rbd<span class="token punctuation">.</span><span class="token function">CreateImage</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> ImageName<span class="token punctuation">,</span> ImageSize<span class="token punctuation">,</span> rbd<span class="token punctuation">.</span><span class="token function">NewRbdImageOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取或者修改Image时，需要先OpenImage，或者OpenImageReadOnly</span>rbdImage<span class="token punctuation">,</span> err <span class="token operator">:=</span> rbd<span class="token punctuation">.</span><span class="token function">OpenImageReadOnly</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> ImageName<span class="token punctuation">,</span> rbd<span class="token punctuation">.</span>NoSnapshot<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> err <span class="token operator">==</span> rbd<span class="token punctuation">.</span>ErrNotFound <span class="token punctuation">&#123;</span>log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"image not found"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>rbdImage<span class="token punctuation">.</span><span class="token function">GetId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说，开发起来还是挺简单的。最终我也把上面需求的这些功能，封装成了HTTP API，代码也放到了<a href="https://github.com/C0reFast/rbd-api">C0reFast&#x2F;rbd-api</a>。相对官方的API来说，简单、速度快、所有操作全部是同步的，希望有一天在类似的场景下能发挥一些作用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多人看到这个标题会很奇怪，Ceph不是有一个&lt;a href=&quot;https://docs.ceph.com/en/pacific/mgr/ceph_api/index.html&quot;&gt;RESTful API&lt;/a&gt;么，为什么又要造一遍轮子？&lt;/p&gt;
&lt;p&gt;的确，Ceph的官方组件Dashboard，内置了一些非常强大的RESTful API，功能也是比较的全面。为啥又要自己写一个呢？在我们的环境里，有一个自己实现的类似Openstack的虚拟机管理平台。而这个平台对接Ceph RBD时，就是使用的Dashboard模块提供的API。个人觉得啊，官方的API，虽然功能全，但确实对于对接的用户来说，真的不是那么友好。这里举几个简单的点：&lt;/p&gt;</summary>
    
    
    
    <category term="Ceph" scheme="https://www.ichenfu.com/categories/Ceph/"/>
    
    
    <category term="go-ceph" scheme="https://www.ichenfu.com/tags/go-ceph/"/>
    
    <category term="RBD" scheme="https://www.ichenfu.com/tags/RBD/"/>
    
    <category term="HTTP API" scheme="https://www.ichenfu.com/tags/HTTP-API/"/>
    
  </entry>
  
  <entry>
    <title>服务器网络启动方式探索Part2：UEFI启动篇</title>
    <link href="https://www.ichenfu.com/2021/12/25/server-net-boot-part-2-uefi/"/>
    <id>https://www.ichenfu.com/2021/12/25/server-net-boot-part-2-uefi/</id>
    <published>2021-12-25T09:31:14.000Z</published>
    <updated>2021-12-27T02:05:47.101Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="/2021/11/28/server-net-boot-part-1-legacy/">服务器网络启动方式探索Part1：Legacy启动篇</a>里，总结了一些在Legacy启动模式下的一些网络启动方案，那么这一篇，很自然的就需要介绍一下在纯UEFI模式下的网络启动了。</p><p>相比Legacy启动直接读取MBR启动分区的第一个扇区作为引导的逻辑，UEFI启动变得强大了很多，在UEFI模式下，固件直接具有的读取FAT文件系统的能力，并且直接通过运行EFI可执行文件的方式进行引导。<br>因为这个显而易见的变化，导致对应到PXE相关的实现上，也会有相应的区别。不过相比于Legacy启动的那些方案，区别不是那么大，依然是可以做到功能上一一对应的，同样的，我们从最简单的情况开始看起。</p><span id="more"></span><h2 id="UEFI-Boot-PXE"><a href="#UEFI-Boot-PXE" class="headerlink" title="UEFI Boot + PXE"></a>UEFI Boot + PXE</h2><p>这个方案依然是配置最简单的方案，和Legacy+PXE一样，也是需要ftp server和DHCP，只是DHCP服务器的配置有些不一样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">option domain-name-servers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>option routers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>ddns-update-style none<span class="token punctuation">;</span>subnet <span class="token number">10.1</span>.1.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">&#123;</span>    range dynamic-bootp <span class="token number">10.1</span>.1.100 <span class="token number">10.1</span>.1.120<span class="token punctuation">;</span>    default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>    max-lease-time <span class="token number">172800</span><span class="token punctuation">;</span>    next-server <span class="token number">10.1</span>.1.10<span class="token punctuation">;</span>   <span class="token comment">#关键配置！用于指明tftp server的地址</span>    filename <span class="token string">"grubx64.efi"</span><span class="token punctuation">;</span>   <span class="token comment">#关键配置！用于指明bootloader的名字</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现其他的都没变化，只是把<code>filename</code>的配置换成了<code>grubx64.efi</code>，这意味着在UEFI启动里，放弃了使用<code>pxelinux</code>，转而使用了<code>grub</code>，当然其实SYSLINX也是有efi的，文件名<code>syslinux.efi</code>，但是因为确实用的比较少，所以在这个环境里就换成了<code>grub</code>作为Bootloader。</p><p>接下来是<code>grubx64.efi</code>和配置文件的准备，以rhel举例，如果本身机器就是用的UEFI启动，那直接可以从<code>/boot/efi/EFI/redhat/grubx64.efi</code>拷贝，如果系统本身还是MBR安装，那可以可以参考<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/chap-installation-server-setup">红帽的文档</a></p><p>然后是配置文件，和<code>PXELINUX</code>一样，grub也是支持根据客户端的不同加载不同的配置文件的。具体的可以参考一下grub的文档:<a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Network">8 Booting GRUB from the network</a><br>不过我们也不需要多配置文件了，只需要配置一个<code>grub.cfg</code>就行，把这个配置文件放在和grubx64.efi同目录下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">5</span>menuentry <span class="token string">'RHEL'</span> <span class="token punctuation">&#123;</span>  linuxefi images/vmlinuz  initrdefi images/initrd.img<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此一个最简单的UEFI的PXE启动方式就配置完成了。</p><h2 id="UEFI-Boot-iPXE"><a href="#UEFI-Boot-iPXE" class="headerlink" title="UEFI Boot + iPXE"></a>UEFI Boot + iPXE</h2><p>接下来就是iPXE了，相比于PXE来说，iPXE的变化要小的多，因为自带了bootloader，所以只需要把<code>filename</code>换成<code>ipxe.efi</code>就行了:</p><pre class="line-numbers language-none"><code class="language-none">option domain-name-servers 10.1.1.1;option routers 10.1.1.1;default-lease-time 14400;ddns-update-style none;subnet 10.1.1.0 netmask 255.255.255.0 &#123;    range dynamic-bootp 10.1.1.100 10.1.1.120;    default-lease-time 14400;    max-lease-time 172800;    next-server 10.1.1.10;   #关键配置！用于指明tftp server的地址    if exists user-class and option user-class &#x3D; &quot;iPXE&quot; &#123; #根据user-class字段来判断客户端类型      filename &quot;http:&#x2F;&#x2F;10.1.1.10&#x2F;boot.script&quot;;    &#125; else &#123;      filename &quot;ipxe.efi&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，<code>ipxe.efi</code>可以从<a href="http://boot.ipxe.org/">http://boot.ipxe.org</a>直接下载。剩下的关于<code>boot.script</code>配置，和上一篇Legacy里的配置是一致的。这里就不用赘述了。</p><h2 id="UEFI-HTTP-Boot"><a href="#UEFI-HTTP-Boot" class="headerlink" title="UEFI HTTP Boot"></a>UEFI HTTP Boot</h2><p>对于iPXE来说，支持通过HTTP&#x2F;FTP等等基于TCP传输的协议来获取kernel和initrd文件，速度相比于之前的PXE的tftp要快很多倍，但是如果稍微有那么一点点强迫症的话，依然会觉得整个iPXE方案里始终存在一个不太和谐的点。<br>是的，虽然kernel和initrd等文件可以通过HTTP获取，但是对于iPXE本身，无论是Legacy模式还是UEFI模式下，都依然需要用到tftp，虽然iPXE文件本身很小，只有KB级别，不会影响启动的速度了，但是tftp始终是一个依赖，这对于一个想Keep it Simple、Stupid的启动方式来说，实在是有那么些不舒服，如果能有什么办法（当然，直接把网卡刷成iPXE的方案不算）解决掉tftp的依赖，那显然是极好的。</p><p>对于这个问题呢，设计固件的聪明人们自然也想到了，于是就在UEFI 2.5的SPEC里，加上了<code>HTTP Boot</code>的功能，直接让UEFI可以从HTTP URL获取启动文件，并通过这个启动文件启动系统，对于这个方案，目前已知的情况是，Intel提供的UEFI标准实现<a href="https://github.com/tianocore/edk2">edk2</a>是支持的，文档可以参考<a href="https://edk2-docs.gitbook.io/getting-started-with-uefi-https-boot-on-edk-ii/">Getting Started with UEFI HTTPS Boot on EDK II</a>，除此之外，<a href="https://www.dell.com/support/kbdoc/zh-cn/000138011/http-boot-in-sles-15?lang=en">Dell</a>、<a href="https://lenovopress.com/lp0736-using-http-boot-to-install-an-operating-system">联想</a>、<a href="https://support.hpe.com/hpesc/public/docDisplay?docId=c05088241&docLocale=en_US">HPE</a>等等国际大厂以及<a href="https://www.redhat.com/sysadmin/uefi-http-boot-libvirt">虚拟机</a>也是明确有相关文档支持的，，而对于国内的一些厂商，目前我知道的情况是大部分都支持，不过因为确实国内用的比较少，很多厂商并没有非常仔细的测试。</p><p>我找了一台Dell的服务器，目前测试是没问题的，对于HTTP Boot来说，依然是通过DHCP获取启动配置，和iPXE类似，会带上一个特殊的标记，来区分普通PXE和HTTP Boot的区别，在iPXE文档<a href="https://ipxe.org/appnote/uefihttp">UEFI HTTP chainloading</a>里，也明确表示了iPXE支持这种启动方式。下面是个可以参考的DHCP服务器的配置：</p><pre class="line-numbers language-none"><code class="language-none">option domain-name-servers 10.1.1.1;option routers 10.1.1.1;default-lease-time 14400;ddns-update-style none;subnet 10.1.1.0 netmask 255.255.255.0 &#123;    range dynamic-bootp 10.1.1.100 10.1.1.120;    default-lease-time 14400;    max-lease-time 172800;    next-server 10.1.1.10;    if exists user-class and option user-class &#x3D; &quot;iPXE&quot; &#123; #根据user-class字段来判断客户端类型      filename &quot;http:&#x2F;&#x2F;10.1.1.10&#x2F;boot.script&quot;;    &#125; elsif substring (option vendor-class-identifier, 0, 10) &#x3D; &quot;HTTPClient&quot; &#123; # UEFI HTTP BOOT      filename &quot;http:&#x2F;&#x2F;10.1.1.10&#x2F;ipxe.efi&quot;;    &#125; else &#123;      filename &quot;ipxe.efi&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过判断<code>vendor-class-identifier</code>字段是否是<code>HTTPClient</code>，来确认是否是UEFI HTTP BOOT，如果是HTTP Boot，那就把iPXE启动文件的URL返回，这样UEFI固件就可以通过HTTP协议获取iPXE启动文件，接下来的过程就和iPXE没有区别了。如此一来，如果UFEI支持HTTP Boot并开启，那么就完全不需要tftp，只需要一个HTTP服务器就可以完成所有的启动过程了。真正意义上去除了对tftp的依赖。<br>当然，如果想基于grub或者其他bootloader启动的话，也是可以的，基本原理也差不多，感兴趣的话，可以试试。</p><h2 id="Secure-boot"><a href="#Secure-boot" class="headerlink" title="Secure boot"></a>Secure boot</h2><p>对于UEFI来说，还有一个非常重要的特性：Secure boot（安全启动），开启Secure boot之后，UEFI会利用数字签名来确认EFI驱动程序或者应用程序是否是受信任的，这其中就包括了从网络下载的bootloader，一般来说，大多数常见的OS发行版都会对Secure boot进行支持，具体支持的原理，这里就不作过多的介绍了，具体的可以参考一下红帽的文档：<a href="https://access.redhat.com/articles/5254641">What is UEFI Secure Boot and how it works?</a>。<br>需要说明的事，这篇Blog以及上一篇Blog所讨论的方法，都不涉及Secure boot，或者说这些配置都无法在Secure boot开启的情况下正常工作。但是也需要稍微进行一些修改，就可以顺利的在Secure boot环境下启动。大致的思路就是把bootloader换成一个受信任的shim，具体的实践，还需要大家自己去测试。</p><h2 id="真正的总结"><a href="#真正的总结" class="headerlink" title="真正的总结"></a>真正的总结</h2><p>最近确实花了很多时间去研究服务器的网络启动方案，从PXE开始，到HTTP Boot结束，几乎把所有相关的可能性都测试了一遍，想找到一个依赖少、稳定、兼容性好的网络启动方案。然而实际情况是，面对的OEM厂商实在是太多了，每个厂商开发固件时的侧重点也不尽相同，导致在我个人内心中最完美的HTTP Boot方案，几乎没办法真正意义上在线上环境跑通。相对的，反而是最原始功能最少的方案，跨厂商的兼容性最好。</p><p>其实一开始的目的不仅于此，如果要深究的话，其实在UEFI这种模式下，甚至有可能去除掉DHCP服务器这个依赖，理论上在UEFI模式下，固件是有自己的一套协议栈的，在PXE之前，是可以手动给网卡配置静态的IP地址，网关，DNS等等网络配置，同样的bootloader的位置也是可以静态指定的，除此之外，还有很多tricky的手段，不过这些方案总归兼容性堪忧，特别是国内的很多服务器厂商，大多对于这些高级功能缺乏测试。感兴趣的同学可以花点时间时间研究研究，还是挺有意思的😄。同样也是希望国内厂商能给力起来，像国际大厂们看齐，不断完善好固件等等各个方面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;/2021/11/28/server-net-boot-part-1-legacy/&quot;&gt;服务器网络启动方式探索Part1：Legacy启动篇&lt;/a&gt;里，总结了一些在Legacy启动模式下的一些网络启动方案，那么这一篇，很自然的就需要介绍一下在纯UEFI模式下的网络启动了。&lt;/p&gt;
&lt;p&gt;相比Legacy启动直接读取MBR启动分区的第一个扇区作为引导的逻辑，UEFI启动变得强大了很多，在UEFI模式下，固件直接具有的读取FAT文件系统的能力，并且直接通过运行EFI可执行文件的方式进行引导。&lt;br&gt;因为这个显而易见的变化，导致对应到PXE相关的实现上，也会有相应的区别。不过相比于Legacy启动的那些方案，区别不是那么大，依然是可以做到功能上一一对应的，同样的，我们从最简单的情况开始看起。&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="UEFI" scheme="https://www.ichenfu.com/tags/UEFI/"/>
    
    <category term="PXE" scheme="https://www.ichenfu.com/tags/PXE/"/>
    
    <category term="HTTP Boot" scheme="https://www.ichenfu.com/tags/HTTP-Boot/"/>
    
  </entry>
  
  <entry>
    <title>服务器网络启动方式探索Part1：Legacy启动篇</title>
    <link href="https://www.ichenfu.com/2021/11/28/server-net-boot-part-1-legacy/"/>
    <id>https://www.ichenfu.com/2021/11/28/server-net-boot-part-1-legacy/</id>
    <published>2021-11-28T07:41:38.000Z</published>
    <updated>2021-11-29T02:08:02.527Z</updated>
    
    <content type="html"><![CDATA[<p>最近花了很多时间、调研了服务器的网络启动方案，目的呢是想设计并实现一个更加统一和标准化的装机系统尽最大努力把物理机、裸金属、虚拟机、以及基于裸金属的虚拟机的操作系统镜像和装机方案融合起来，同时能适应现代的硬件。<br>本来以为是一件很轻松的事情，毕竟基于PXE的方案已经运行很多年了，似乎简单的修改一些问题、老方案上打打补丁就能很好的实现。但现实又被疯狂打脸，因为面对多个OEM厂商提供的服务器、每家厂商不同的BMC管理系统、每家厂商不同的接口格式和功能。在没有统一服务器供应商或者基于ODM方案之前，似乎那个“完美”的方案并不很容易实现。</p><p>不过呢，这些问题也都不重要，关键是在整个调研的过程中，也是补足了很多似懂非懂、一知半解的技术细节，也算是一个非常大的提升了，其实短期的妥协方案，也不影响最终的实现效果。所以准备写写这段时间学习到的知识，也算是补足了之前网络上找不到技术细节的坑吧，本篇算是第一部分吧，从最简单的开始，说说当前Legacy Boot相关的网络启动方案。</p><span id="more"></span><h2 id="UEFI-Legacy-Boot-PXE"><a href="#UEFI-Legacy-Boot-PXE" class="headerlink" title="UEFI Legacy Boot + PXE"></a>UEFI Legacy Boot + PXE</h2><p>虽然现在所有的服务器厂商都将<code>BIOS</code>的实现换成了<code>UEFI</code>，但为了兼容性考虑，所有的厂商依然提供老的<code>BIOS</code>形式的基于<code>MBR</code>的<code>Legacy</code>引导方式，在这个模式下，通过PXE可以实现最基础的功能。</p><p>在Legacy模式下，简单来说，PXE是通过网卡内置的一个小固件（PXE Client）实现的。大致的流程可以总结成这样：在系统启动的时候，会启动网卡里的<code>PXE Client</code>，固件启动后、会发起DHCP请求、当DHCP服务器收到<code>PXE Client</code>的DHCP请求后，会通过预定义的字段返回给客户端IP地址信息、TFTP地址信息、以及需要加载的<code>bootloader</code>的名字。<code>PXE Client</code>收到这些信息后，首先会配置IP地址，此时网络就可以通信了，再根据TFTP的地址和名字信息获取到<code>bootloader</code>并执行，剩下的，就由<code>bootloader</code>去拉起内核和OS。</p><p>接下来我们尝试搭建一个<code>PXE Server</code>试试：</p><p>首先<code>PXE Server</code>依赖两个组件：DHCP Server和TFTP，先配置DHCP Server：</p><p>这里使用<code>isc-dhcp-server</code>，附上配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">option domain-name-servers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>option routers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>ddns-update-style none<span class="token punctuation">;</span>subnet <span class="token number">10.1</span>.1.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">&#123;</span>    range dynamic-bootp <span class="token number">10.1</span>.1.100 <span class="token number">10.1</span>.1.120<span class="token punctuation">;</span>    default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>    max-lease-time <span class="token number">172800</span><span class="token punctuation">;</span>    next-server <span class="token number">10.1</span>.1.10<span class="token punctuation">;</span>   <span class="token comment">#关键配置！用于指明tftp server的地址</span>    filename <span class="token string">"pxelinux.0"</span><span class="token punctuation">;</span>   <span class="token comment">#关键配置！用于指明bootloader的名字</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他部分的配置并不重要，针对PXE启动来说，最重要的配置只有<code>next-server</code>和<code>filename</code>，<code>next-server</code>指明了tftp server服务器的地址，<code>filename</code>指明了<code>bootloader</code>的名字，有了这俩信息，<code>PXE Client</code>就可以去tftp上去获取bootloader并加载了。</p><p>接下来，配置tftp。tftp其实不需要配置，安装并启动就行了。主要是需要准备好启动所需要的bootloader和内核、initrd等文件。在配置文件里的<code>pxelinux.0</code>是从哪来的呢？为了简单、一般来说PXE里不使用grub作为<code>bootloader</code>、使用最多的还是<code>PXELINUX</code>，他是<code>syslinux</code>的一部分，所以很简单，只需要安装<code>syslinux</code>就行了，在我的CentOS系统里，这个文件在<code>/usr/share/syslinux/pxelinux.0</code>。直接拷贝到tftp root目录下就行。需要注意的是，在<code>syslinux</code> 5.0以上的版本，还需要把<code>ldlinux.c32</code>这个文件同步拷贝到tftp root下。</p><p>有了<code>bootloader</code>、还需要<code>bootloader</code>配置文件，针对<code>pxelinux</code>而言，默认会根据以下的顺序加载配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/pxelinux.cfg/b8945908-d6a6-41a9-611d-74a6ab80b83d/pxelinux.cfg/01-88-99-aa-bb-cc-dd/pxelinux.cfg/C0A8025B/pxelinux.cfg/C0A8025/pxelinux.cfg/C0A802/pxelinux.cfg/C0A80/pxelinux.cfg/C0A8/pxelinux.cfg/C0A/pxelinux.cfg/C0/pxelinux.cfg/C/pxelinux.cfg/default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中根目录指的是和<code>pxelinux.0</code>相同的目录，具体每个文件所代表的含义，可以参考<a href="https://wiki.syslinux.org/wiki/index.php?title=PXELINUX">PXELINUX的文档</a>这么做的目的呢，是为了方便同一个PXE Server为多个机器服务，每个机器可以通过单独的配置文件进行配置，而不用为每台客户端配置一个PXE Server了。实际上、有一个广泛使用的装机系统<code>cobbler</code>、也是基于这个特性，来解决不同机器的不同装机配置问题的。</p><p>在我们只有一台机器的情况下，默认写一个<code>pxelinux.cfg/default</code>文件就行了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">DEFAULT test-pxe-bootLABEL test-pxe-boot  MENU LABEL ^Test Boot  KERNEL vmlinuz  APPEND <span class="token assign-left variable">initrd</span><span class="token operator">=</span>initrd.img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件很简单，指明KERNEL和initrd的位置就行，默认情况下这些文件依然会从tftp里去取。至于<code>vmlinuz</code>和<code>initrd.img</code>这两个文件的获取，这里就不多说了，最简单的办法，就是从发行版的iso安装镜像里去找就可以了。</p><p>到目前为止，一个最简单的PXE Server就搭建完成了。已经可以测试是否能拉起一个RamOS了。当然，我们用的<code>PXELINUX</code>还有很多高级的用法，比如基于http去加载kernel和initrd，从而绕开tftp协议进行加速，或者通过dhcpd下发一些配置等等，这里就不多说了，可以继续参考<a href="https://wiki.syslinux.org/wiki/index.php?title=PXELINUX">PXELINUX的文档</a>。</p><h2 id="UEFI-Legacy-Boot-iPXE"><a href="#UEFI-Legacy-Boot-iPXE" class="headerlink" title="UEFI Legacy Boot + iPXE"></a>UEFI Legacy Boot + iPXE</h2><p>基于PXE的启动已经很成熟了，但是对于PXE的一个重要依赖，tftp来说，大家还是会觉得他太慢了，毕竟tftp还是比较适用于小文件的传输，在实际的应用中，如果你的initrd.img比较大的话，那么需要花的时间就比较可观了，根据我自己的测试，大概传输200M左右的数据至少也需要60s，即使你用的是25GbE的网卡，依然是这个速度。那么，有没有支持更多协议的方法呢？</p><p>答案自然是有的，那就是iPXE，相比于比较原始的PXE来说，iPXE极大的增强了功能，根据<a href="https://ipxe.org/">官网</a>的描述，相比PXE来说，主要有以下的提升：</p><blockquote><ul><li>boot from a web server via HTTP</li><li>boot from an iSCSI SAN</li><li>boot from a Fibre Channel SAN via FCoE</li><li>boot from an AoE SAN</li><li>boot from a wireless network</li><li>boot from a wide-area network</li><li>boot from an Infiniband network</li><li>control the boot process with a script</li></ul></blockquote><p>可以看到，功能和可编程性提升了很多，尤其重要的，一个是可以支持HTTP协议了，另外还有脚本执行能力，易用性大幅度的提升了。</p><p>而对于iPXE，主要有两种使用方式，一种方式，就是把iPXE直接烧进网卡的ROM里，替换掉网卡老的PXE ROM，这样就直接启动到iPXE环境了，另外一种，就是使用链式加载的模式，iPXE支持通过PXE环境、ISO、UEFI、以及其他引导器运行，也就是说，可以先通过PXE启动到iPXE环境，再对iPXE环境进行配置，从而实现系统启动。</p><p>这里主要还是会以链式加载的方式进行试验，相比直接刷ROM的方式，兼容性和可操作性都比较好。</p><p>那首先第一步还是要实现PXE的配置，只是这次的bootloader要从<code>PXELINUX</code>换成了<code>iPXE</code>，对于DHCP Server来说，配置不会变化太大：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">option domain-name-servers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>option routers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>ddns-update-style none<span class="token punctuation">;</span>subnet <span class="token number">10.1</span>.1.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">&#123;</span>    range dynamic-bootp <span class="token number">10.1</span>.1.100 <span class="token number">10.1</span>.1.120<span class="token punctuation">;</span>    default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>    max-lease-time <span class="token number">172800</span><span class="token punctuation">;</span>    next-server <span class="token number">10.1</span>.1.10<span class="token punctuation">;</span>  <span class="token comment">#关键配置！用于指明tftp server的地址</span>    filename <span class="token string">"ipxe.pxe"</span><span class="token punctuation">;</span>    <span class="token comment">#关键配置！用于指明ipxe的名字</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，只要把filename换成ipxe的名字就可以了，而这个<code>ipxe.pxe</code>，可以从<a href="http://boot.ipxe.org/">http://boot.ipxe.org</a>直接下载，顺便说一下，这个网站里还包括了其他环境使用的iPXE，比如UFEI使用的，或者iso、U盘启动使用的启动文件，触类旁通，可以根据需求下载不同的文件。</p><p>配置好DHCP Server、下载好文件之后，只要一启动，iPXE就会被拉起。但是问题还没结束，为什么呢，因为iPXE被拉起之后，还是会通过DHCP协议获取IP地址和其他启动的配置，但是思考一下，当iPXE获取DHCP配置的时候，按我们现在的配置，服务器依然会把<code>filename: ipxe.pxe</code>返回给iPXE客户端，然后iPXE拉起iPXE，如此反复，进入了一个死循环。</p><p>所以得需要有个办法来打破这个死循环，对于这个问题，官方也给出了对应的<a href="https://ipxe.org/howto/chainloading">方案</a>，一种是将脚本直接嵌入到ipxe文件里，另外一个，就是通过配置DHCP Server实现，由于将脚本嵌入到ipxe文件里需要自己编译，那肯定不是个简单的方案，所以这里还是优先通过配置DHCP Server完成目标。</p><p>先想想原理，其实也比较简单，如果DHCP Server能感知到客户端是PXE还是iPXE，如果是PXE，就把”ipxe.pxe”作为文件名传给客户端，如果是iPXE，就把iPXE Script的文件名传给客户端，这样一个简单的if判断，就可以打破这个死循环了，而iPXE确实给我们一个非常明确的区分方式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">option domain-name-servers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>option routers <span class="token number">10.1</span>.1.1<span class="token punctuation">;</span>default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>ddns-update-style none<span class="token punctuation">;</span>subnet <span class="token number">10.1</span>.1.0 netmask <span class="token number">255.255</span>.255.0 <span class="token punctuation">&#123;</span>    range dynamic-bootp <span class="token number">10.1</span>.1.100 <span class="token number">10.1</span>.1.120<span class="token punctuation">;</span>    default-lease-time <span class="token number">14400</span><span class="token punctuation">;</span>    max-lease-time <span class="token number">172800</span><span class="token punctuation">;</span>    next-server <span class="token number">10.1</span>.1.10<span class="token punctuation">;</span>   <span class="token comment">#关键配置！用于指明tftp server的地址</span>    <span class="token keyword">if</span> exists user-class and option user-class <span class="token operator">=</span> <span class="token string">"iPXE"</span> <span class="token punctuation">&#123;</span> <span class="token comment">#根据user-class字段来判断客户端类型</span>      filename <span class="token string">"http://10.1.1.10/boot.script"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      filename <span class="token string">"ipxe.pxe"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于iPXE来说，在发送DHCP请求的时候，会加上一个user-class Option，值是”iPXE”，根据这个信息，我们就可以区分到底现在是PXE环境还是iPXE环境了。然后就是filename的配置，因为iPXE支持http协议，所以在filename字段，就可以直接填一个URL了，这样就可以把boot.script放到一个HTTP服务器上了。一个最简单的boot.script可以这样写：</p><pre class="line-numbers language-none"><code class="language-none">#!ipxekernel http:&#x2F;&#x2F;10.1.1.10&#x2F;vmlinuz initrd&#x3D;initrd.imginitrd http:&#x2F;&#x2F;10.1.1.10&#x2F;initrd.imgboot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为支持HTTP协议，内核和initrd.img文件也都可以放在HTTP服务器上了，相比用tftp协议去获取，速度快了10倍不止。同样的，因为支持HTTP协议，对于多台机器同时装机的需求，可以实现的方式就更多了。一个最简单的思路就是使用php或者其他编程语言实现一个页面，在DHCP服务器把返回filename配置成<code>http://10.1.1.10/boot.php</code>，然后程序里根据不同机器的配置，生成不同的<code>ipxe script</code>。iPXE根据不同机器的不同script，来定制化不同的启动逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，基于UEFI Legacy Boot的网络启动方式基本就说完了，当初PXE协议的设计者们的思路还是十分清晰的。而每个bootloader对于在PXE环境下多配置文件的支持，也是很早就设计好的，在上面的这些例子里，特别是PXE的例子，除了<code>PXELINUX</code>之外，理论上<code>grub</code>或者其他bootloader，都可以很好的完成类似的任务，比如grub的配置文件加载顺序，也可以找到非常完整的<a href="https://www.gnu.org/software/grub/manual/grub/html_node/Network.html">文档</a>。而对于后来者iPXE，确实功能上增强了不少，可编程性也有了很大的提升，同时自身也可以作为bootloader，相比之下，确实iPXE会是一个非常好的选择。</p><p>下一篇我们再说说UFEI模式下的网络启动，尽情期待！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近花了很多时间、调研了服务器的网络启动方案，目的呢是想设计并实现一个更加统一和标准化的装机系统尽最大努力把物理机、裸金属、虚拟机、以及基于裸金属的虚拟机的操作系统镜像和装机方案融合起来，同时能适应现代的硬件。&lt;br&gt;本来以为是一件很轻松的事情，毕竟基于PXE的方案已经运行很多年了，似乎简单的修改一些问题、老方案上打打补丁就能很好的实现。但现实又被疯狂打脸，因为面对多个OEM厂商提供的服务器、每家厂商不同的BMC管理系统、每家厂商不同的接口格式和功能。在没有统一服务器供应商或者基于ODM方案之前，似乎那个“完美”的方案并不很容易实现。&lt;/p&gt;
&lt;p&gt;不过呢，这些问题也都不重要，关键是在整个调研的过程中，也是补足了很多似懂非懂、一知半解的技术细节，也算是一个非常大的提升了，其实短期的妥协方案，也不影响最终的实现效果。所以准备写写这段时间学习到的知识，也算是补足了之前网络上找不到技术细节的坑吧，本篇算是第一部分吧，从最简单的开始，说说当前Legacy Boot相关的网络启动方案。&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="UEFI" scheme="https://www.ichenfu.com/tags/UEFI/"/>
    
    <category term="PXE" scheme="https://www.ichenfu.com/tags/PXE/"/>
    
    <category term="Legacy" scheme="https://www.ichenfu.com/tags/Legacy/"/>
    
  </entry>
  
  <entry>
    <title>WSL2 Ubuntu 21.04原生Docker无法运行的问题</title>
    <link href="https://www.ichenfu.com/2021/10/23/wsl2-ubuntu-dockerd-iptables-problem/"/>
    <id>https://www.ichenfu.com/2021/10/23/wsl2-ubuntu-dockerd-iptables-problem/</id>
    <published>2021-10-23T11:27:32.000Z</published>
    <updated>2021-11-29T02:08:02.527Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了用上更新一点的软件，把运行在WSL2里的Ubuntu 20.04 LTS版本升级了一下，升级到了Ubuntu 21.04，升级之后呢，大部分功能都正常（当然本身我用的功能也不会很多），但是确实也遇到了个小问题：Docker Daemon无法启动了。这个确实很影响工作，因为很多时候写完代码会本地打个镜像运行一下，简单测试一下代码是否有问题。但是升级之后，突然发现Docker用不了了。</p><p>具体点呢，是会报一个<code>iptables</code>相关的错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>WARN<span class="token punctuation">[</span><span class="token number">2021</span>-10-23T11:30:05.864210900+08:00<span class="token punctuation">]</span> Your kernel does not support cgroup blkio throttle.write_iops_deviceINFO<span class="token punctuation">[</span><span class="token number">2021</span>-10-23T11:30:05.864538700+08:00<span class="token punctuation">]</span> Loading containers: start.INFO<span class="token punctuation">[</span><span class="token number">2021</span>-10-23T11:30:06.135353300+08:00<span class="token punctuation">]</span> stopping event stream following graceful <span class="token function">shutdown</span>  <span class="token assign-left variable">error</span><span class="token operator">=</span><span class="token string">"context canceled"</span> <span class="token assign-left variable">module</span><span class="token operator">=</span>libcontainerd <span class="token assign-left variable">namespace</span><span class="token operator">=</span>mobyINFO<span class="token punctuation">[</span><span class="token number">2021</span>-10-23T11:30:06.135542600+08:00<span class="token punctuation">]</span> stopping healthcheck following graceful <span class="token function">shutdown</span>  <span class="token assign-left variable">module</span><span class="token operator">=</span>libcontainerdINFO<span class="token punctuation">[</span><span class="token number">2021</span>-10-23T11:30:06.136083800+08:00<span class="token punctuation">]</span> stopping event stream following graceful <span class="token function">shutdown</span>  <span class="token assign-left variable">error</span><span class="token operator">=</span><span class="token string">"context canceled"</span> <span class="token assign-left variable">module</span><span class="token operator">=</span>libcontainerd <span class="token assign-left variable">namespace</span><span class="token operator">=</span>plugins.mobyfailed to start daemon: Error initializing network controller: error obtaining controller instance: unable to <span class="token function">add</span> <span class="token builtin class-name">return</span> rule <span class="token keyword">in</span> DOCKER-ISOLATION-STAGE-1 chain:  <span class="token punctuation">(</span>iptables failed: iptables <span class="token parameter variable">--wait</span> <span class="token parameter variable">-A</span> DOCKER-ISOLATION-STAGE-1 <span class="token parameter variable">-j</span> RETURN: iptables v1.8.7 <span class="token punctuation">(</span>nf_tables<span class="token punctuation">)</span>:  RULE_APPEND failed <span class="token punctuation">(</span>No such <span class="token function">file</span> or directory<span class="token punctuation">)</span>: rule <span class="token keyword">in</span> chain DOCKER-ISOLATION-STAGE-1 <span class="token punctuation">(</span>exit status <span class="token number">4</span><span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><p>提示<code>iptables</code> <code>RULE_APPEND</code>也不知道是咋回事，不过想着估计和Docker的网络有点关系，还好一般情况下编译和打镜像也不需要网络隔离，所以前几天就临时在启动Docker Daemon时加上<code>--iptables=false</code>参数，不加载iptables规则，当然<code>docker builld</code>和<code>docker run</code>的时候也得加上<code>--network=host</code>使用不隔离的Host网络，勉强扛了几天。</p><p>今天有时间就查了查资料，一开始查到的大部分都是让用<code>Docker Desktop for Windows</code>并且开启WSL2后端，然后在WSL2里直接用Windows的<code>docker.exe</code>命令。这个方案我没试过，不过说实话即使能用，也觉得有点太别扭了。想想还是放弃了。于是继续找资料。终于找到一篇<a href="https://patrickwu.space/2021/03/09/wsl-solution-to-native-docker-daemon-not-starting/">文章</a>，文章里贴了个Ubuntu的<a href="https://bugs.launchpad.net/ubuntu-wsl-integration/+bug/1908539">bug report</a>，大致意思是说：</p><blockquote><p>Ubuntu从20.10开始，将默认的防火墙切换到了<code>nftables</code>实现，这个实现需要5.8版本及以上的内核，而微软在WSL2中提供的5.4版本的内核没有<code>nftables</code>，所以导致iptables功能出错了。</p></blockquote><p>解决方法也简单，直接把<code>iptables</code>实现切换回<code>iptables-legacy</code>就好了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~<span class="token punctuation">]</span><span class="token comment"># sudo update-alternatives --config iptables</span>There are <span class="token number">2</span> choices <span class="token keyword">for</span> the alternative iptables <span class="token punctuation">(</span>providing /usr/sbin/iptables<span class="token punctuation">)</span>.  Selection    Path                       Priority   Status------------------------------------------------------------* <span class="token number">0</span>            /usr/sbin/iptables-nft      <span class="token number">20</span>        auto mode  <span class="token number">1</span>            /usr/sbin/iptables-legacy   <span class="token number">10</span>        manual mode  <span class="token number">2</span>            /usr/sbin/iptables-nft      <span class="token number">20</span>        manual modePress <span class="token operator">&lt;</span>enter<span class="token operator">></span> to keep the current choice<span class="token punctuation">[</span>*<span class="token punctuation">]</span>, or <span class="token builtin class-name">type</span> selection number: <span class="token number">1</span>update-alternatives: using /usr/sbin/iptables-legacy to provide /usr/sbin/iptables <span class="token punctuation">(</span>iptables<span class="token punctuation">)</span> <span class="token keyword">in</span> manual mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换回去之后，果然就好了，又可以开心的用原生docker了。</p><p>最后我又看了眼现在跑的内核：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~<span class="token punctuation">]</span><span class="token comment"># uname -r</span><span class="token number">5.10</span>.60.1-microsoft-standard-WSL2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为升级了Windows11，现在内核已经到了5.10了。按理不应该有问题才对。除非微软编译内核的时候没开相关的选项？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~<span class="token punctuation">]</span><span class="token comment"># zcat /proc/config.gz |grep NF_TABLES</span><span class="token assign-left variable">CONFIG_NF_TABLES</span><span class="token operator">=</span>y<span class="token assign-left variable">CONFIG_NF_TABLES_INET</span><span class="token operator">=</span>y<span class="token comment"># CONFIG_NF_TABLES_NETDEV is not set</span><span class="token assign-left variable">CONFIG_NF_TABLES_IPV4</span><span class="token operator">=</span>y<span class="token comment"># CONFIG_NF_TABLES_ARP is not set</span><span class="token assign-left variable">CONFIG_NF_TABLES_IPV6</span><span class="token operator">=</span>y<span class="token comment"># CONFIG_NF_TABLES_BRIDGE is not set</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>确实有些选项没打开，而且WSL的github issue里似乎也有类似的讨论：<a href="https://github.com/microsoft/WSL/issues/6655">#6655</a>、<a href="https://github.com/microsoft/WSL/issues/6044">#6044</a>、<a href="https://github.com/microsoft/WSL/issues/4165">#4165</a>。不过微软似乎也没想着解决，不过问题不大啦，也没到要自己编译内核的地步。能用就行~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近为了用上更新一点的软件，把运行在WSL2里的Ubuntu 20.04 LTS版本升级了一下，升级到了Ubuntu 21.04，升级之后呢，大部分功能都正常（当然本身我用的功能也不会很多），但是确实也遇到了个小问题：Docker Daemon无法启动了。这个确实很影响工作，因为很多时候写完代码会本地打个镜像运行一下，简单测试一下代码是否有问题。但是升级之后，突然发现Docker用不了了。&lt;/p&gt;
&lt;p&gt;具体点呢，是会报一个&lt;code&gt;iptables&lt;/code&gt;相关的错误：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;
WARN&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2021&lt;/span&gt;-10-23T11:30:05.864210900+08:00&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Your kernel does not support cgroup blkio throttle.write_iops_device
INFO&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2021&lt;/span&gt;-10-23T11:30:05.864538700+08:00&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; Loading containers: start.
INFO&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2021&lt;/span&gt;-10-23T11:30:06.135353300+08:00&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; stopping event stream following graceful &lt;span class=&quot;token function&quot;&gt;shutdown&lt;/span&gt;  &lt;span class=&quot;token assign-left variable&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;context canceled&quot;&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;libcontainerd &lt;span class=&quot;token assign-left variable&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;moby
INFO&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2021&lt;/span&gt;-10-23T11:30:06.135542600+08:00&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; stopping healthcheck following graceful &lt;span class=&quot;token function&quot;&gt;shutdown&lt;/span&gt;  &lt;span class=&quot;token assign-left variable&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;libcontainerd
INFO&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2021&lt;/span&gt;-10-23T11:30:06.136083800+08:00&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; stopping event stream following graceful &lt;span class=&quot;token function&quot;&gt;shutdown&lt;/span&gt;  &lt;span class=&quot;token assign-left variable&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;context canceled&quot;&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;libcontainerd &lt;span class=&quot;token assign-left variable&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;plugins.moby
failed to start daemon: Error initializing network controller: error obtaining controller instance: unable to &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token builtin class-name&quot;&gt;return&lt;/span&gt; rule &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; DOCKER-ISOLATION-STAGE-1 chain:  &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;iptables failed: iptables &lt;span class=&quot;token parameter variable&quot;&gt;--wait&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-A&lt;/span&gt; DOCKER-ISOLATION-STAGE-1 &lt;span class=&quot;token parameter variable&quot;&gt;-j&lt;/span&gt; RETURN: iptables v1.8.7 &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nf_tables&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;:  RULE_APPEND failed &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;No such &lt;span class=&quot;token function&quot;&gt;file&lt;/span&gt; or directory&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;: rule &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; chain DOCKER-ISOLATION-STAGE-1
 &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;exit status &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;))&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="iptables" scheme="https://www.ichenfu.com/tags/iptables/"/>
    
    <category term="WSL2" scheme="https://www.ichenfu.com/tags/WSL2/"/>
    
    <category term="Docker" scheme="https://www.ichenfu.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>京东云无线宝鲁班路由器试用记</title>
    <link href="https://www.ichenfu.com/2021/09/28/jdc-router-luban/"/>
    <id>https://www.ichenfu.com/2021/09/28/jdc-router-luban/</id>
    <published>2021-09-28T13:36:16.000Z</published>
    <updated>2021-09-29T01:16:49.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>很幸运的拿到了京东云出的无线宝鲁班路由器的公测资格，话不多说，先上一波图：<br><img src="/images/jdc3-1.png" alt="盒子1"></p><span id="more"></span><p><img src="/images/jdc3-2.png" alt="盒子2"><br><img src="/images/jdc3-3.png" alt="盒子3"><br><img src="/images/jdc3-4.png" alt="本体"></p><p>从包装盒上可以很明显的看到路由器的配置，整体来说，和第一代区别不大，MTK MT7621的CPU、512M的内存、3LAN+1WAN千兆口，和一代相比，最大的变化在于支持了WiFi6、也就是802.11ax、相比WiFi5来说，还是提升了不少，整体的无线吞吐达到了1775Mbps。虽然没有拆机看下他的配置，但是根据猜想，大概率是+MT7915D的组合。</p><p>虽然都知道MT7621 CPU的性能一般般，但是因为这款CPU有硬件NAT引擎的存在，实际的网络流量传输完全不需要经过CPU处理，所以网络性能其实非常强大，基本上千兆宽带对他来说毫无压力，整体来说，这个配置还是比较均衡的，针对一般的家庭用户可以说是绰绰有余。</p><h2 id="无线性能测试"><a href="#无线性能测试" class="headerlink" title="无线性能测试"></a>无线性能测试</h2><p>比较遗憾的是，虽然鲁班路由器是WiFi6的，但是家里没有WiFi6的终端，因为无线握手的时候，只能倾向于版本低的那一端，所以这次测试，没办法真正感受WiFi6的性能威力了。其实在拿到手的一段时间里，做了非常多的测试工作，这里就不细说了，贴几张测试时的speedtest结果图：<br><img src="/images/jdc3-speed24.png" alt="2.4G测试结果"><br><img src="/images/jdc3-speed5.png" alt="5G测试结果"><br><img src="/images/jdc3-speed5-wall.png" alt="5G穿墙测试结果"></p><p>家里的网络是北京联通300M的宽带，实际用电脑+有线连接去测试，大概可以跑到下行380Mbps、上行38Mbps左右。<br>可以看到，鲁班路由器的测试结果，由于2.4G频段现在的干扰确实太多了（家里手机能搜索到的无线信号就有20多个），测速的表现一般，不过即使这样的环境，也能做到大概80多Mbps的下行速度，并且不影响上行速度，这个下行速度，即使是看视频，理论上也基本不会感受到卡顿了。<br>而5G频段的表现更是比较好，不穿墙的情况下，完全没有任何带宽的损失，即使在更远的位置+穿了一堵墙，也有200多Mbps的带宽，可以说在我现在的网络环境下鲁班路由器完全可以发挥宽带的能力。</p><h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><p>重点来了！对于无线宝路由器来说，除了最基础的网络功能，其实他还具有一个更加牛掰的能力！就是作为边缘计算的计算节点，为京东云的边缘计算平台提供计算、存储和带宽。具体的原理也比较复杂，就不详细探讨了，这里可以简单说一下我作为一个程序猿的理解：</p><p>一般来说，作为家庭宽带，虽然运营商提供了300M、500M甚至的千兆的带宽，但实际上大部分时候，普通人是无法完全利用这么多带宽的，从运营商角度来说，因为大家都用不完，所以他们可以卖个更多人，来获取更多的利益。而无线宝路由器呢，可以在你不用这部分带宽的时候，利用这些闲置的带宽，缓存一些边缘计算需要的数据，比如某一个特别火的视频，这些，等到附近的人（比如和你同一个小区）刚好需要看这个视频，就完全可以直接你家中的路由器中获取数据，而不再需要跑很远到视频网站的服务器上获取数据了。</p><p>这样做的好处很多，一方面看视频的人，因为离数据的距离更小了，可以更快的加载数据，播放变的更加流畅；另一方面针对视频网站也可以少花点流量的费用，服务器的压力也少很多。一举两得。</p><p>当然京东云肯定也不会白嫖了你的带宽、每天，他会根据你对整个平台的贡献打分，根据贡献的多少，发放一部分积分给你，最终可以用这一部分积分去换京东E卡，直接当钱用!以目前的情况来说，大概我家里的宽带，每天能分到差不多2块钱，这么看来还是很不错的。</p><h2 id="坐享其成计划"><a href="#坐享其成计划" class="headerlink" title="坐享其成计划"></a>坐享其成计划</h2><p>既然上面说到了这个路由器可以挣积分换钱，那是不是就存在回本的可能性？是的没错！随着时间的推移，最终积分的数量会超过购买路由所花的钱的，那个时候其实就已经回本了！而京东云还出了一个坐享其成计划，这个计划，保证了你一定能回本！具体来说，只要按照规则，使用路由器1年，即使发的积分不够你买路由器的钱，京东云也会补足这中间的差价，所以说还是非常划算的，四舍五入，啊不用四舍五入，就是不要钱！</p><p>具体的，可以看看链接里的说明：<a href="https://pro.jd.com/mall/active/2zzGFDJD2eeVEKHH93zVH4MTis82/index.html">https://pro.jd.com/mall/active/2zzGFDJD2eeVEKHH93zVH4MTis82/index.html</a><br>也可以直接点击这个链接购买：<a href="https://item.jd.com/100014311519.html">https://item.jd.com/100014311519.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;开箱&quot;&gt;&lt;a href=&quot;#开箱&quot; class=&quot;headerlink&quot; title=&quot;开箱&quot;&gt;&lt;/a&gt;开箱&lt;/h2&gt;&lt;p&gt;很幸运的拿到了京东云出的无线宝鲁班路由器的公测资格，话不多说，先上一波图：&lt;br&gt;&lt;img src=&quot;/images/jdc3-1.png&quot; alt=&quot;盒子1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="无线宝" scheme="https://www.ichenfu.com/tags/%E6%97%A0%E7%BA%BF%E5%AE%9D/"/>
    
    <category term="WIFI6" scheme="https://www.ichenfu.com/tags/WIFI6/"/>
    
    <category term="边缘计算" scheme="https://www.ichenfu.com/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes的Leader选举机制</title>
    <link href="https://www.ichenfu.com/2021/06/16/k8s-leader-elect-resource-lock/"/>
    <id>https://www.ichenfu.com/2021/06/16/k8s-leader-elect-resource-lock/</id>
    <published>2021-06-16T12:13:58.000Z</published>
    <updated>2021-06-18T08:52:10.570Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2021/06/14/systemd-privatenetwork-cause-annoying-logs/">上一篇Blog</a>里遗留一个问题：在打开了<code>kube-proxy</code>得tracing日志之后，除去定时同步iptables得日志之外，还出现了一些<code>Calling handler.OnEndpointsUpdate</code>相关得日志输出，这些输出其实是不太寻常的：</p><pre class="line-numbers language-none"><code class="language-none">13:55:13 localhost kube-proxy[20761]: I0609 13:55:13.290051   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:14 localhost kube-proxy[20761]: I0609 13:55:14.502924   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:15 localhost kube-proxy[20761]: I0609 13:55:15.299633   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:16 localhost kube-proxy[20761]: I0609 13:55:16.515500   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:17 localhost kube-proxy[20761]: I0609 13:55:17.316952   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:18 localhost kube-proxy[20761]: I0609 13:55:18.525537   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:19 localhost kube-proxy[20761]: I0609 13:55:19.326566   20761 config.go:167] Calling handler.OnEndpointsUpdate13:55:20 localhost kube-proxy[20761]: I0609 13:55:20.541238   20761 config.go:167] Calling handler.OnEndpointsUpdate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>频率大约是1s一条，如果熟悉K8S的Watch-List机制的一眼就应该可以看出来原因：因为<code>kube-proxy</code>会watch<code>Endpoints</code>的变化，并对这些变化做相应动作，然后某些<code>Endpoints</code>更新了之后，就触发了这条日志。其实这个机制是没有问题的，在正常的K8S集群里，这些输出也没有问题。但是在我们的集群里就有些不正常了，因为我们当前的应用场景，根本就不存在需要<code>Endpoints</code>的情况！那到底是什么地方触发了<code>Endpoints</code>的更新？</p><span id="more"></span><p>要找到原因，首先得知道是不是真的有对应的<code>Endpoints</code>，并且是不是真的再更新，比较简单，kubectl也支持针对资源的watch操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ ~<span class="token punctuation">]</span><span class="token comment"># kubectl get endpoints --all-namespaces --watch</span>NAMESPACE     NAME                      ENDPOINTS                              AGEdefault       kubernetes                <span class="token number">192.168</span>.0.1:6443                       71dkube-system   kube-controller-manager   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71dkube-system   kube-scheduler            <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71dkube-system   kube-controller-manager   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71dkube-system   kube-scheduler            <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71dkube-system   kube-controller-manager   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71dkube-system   kube-scheduler            <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71dkube-system   kube-controller-manager   <span class="token operator">&lt;</span>none<span class="token operator">></span>                                 71d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现确实在<code>kube-system</code>这个namespace下面有两个endpoint：<code>kube-scheduler</code>、<code>kube-controller-manager</code>，而且也都是不停的在被修改。只是比较奇怪的地方是谁在修改它？修改的目的是啥？于是就获取一下其中一个endpoint看下具体的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ ~<span class="token punctuation">]</span><span class="token comment"># kubectl -n kube-system get endpoints kube-scheduler -oyaml</span>apiVersion: v1kind: Endpointsmetadata:  annotations:    control-plane.alpha.kubernetes.io/leader: <span class="token string">'&#123;"holderIdentity":"192-168-0-1_e1e84d39-8c11-492b-8ee0-7d6eac6b3186","leaseDurationSeconds":15,"acquireTime":"2021-05-08T10:47:31Z","renewTime":"2021-06-16T10:41:23Z","leaderTransitions":9&#125;'</span>  creationTimestamp: <span class="token string">"2021-04-06T08:55:30Z"</span>  name: kube-scheduler  namespace: kube-system  resourceVersion: <span class="token string">"24773276"</span>  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-scheduler  uid: ae3d725e-679d-4410-8655-7ddacb633d1f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到annotations里有个key：<code>control-plane.alpha.kubernetes.io/leader</code>，好像和选举有关啊。之前知道K8S的scheduler和controller-manager以及一些自定义的controller有选举机制来保证同一时刻只有一个实例在工作，但是没仔细研究过到底是怎么实现的，难道是基于endpoints？</p><p>先去看看<code>scheduler</code>的启动参数里，是不是有相关的选项，帮助我们理解一下当前的策略。果然执行<code>kube-scheduler --help</code>之后发现有一些相关的输出：</p><blockquote><p>Leader election flags:</p><pre><code>  --leader-elect            Start a leader election client and gain leadership before executing the main loop. Enable this when running replicated components for high availability. (default true)  --leader-elect-lease-duration duration            The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the            maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled. (default 15s)  --leader-elect-renew-deadline duration            The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled. (default 10s)  --leader-elect-resource-lock endpoints            The type of resource object that is used for locking during leader election. Supported options are endpoints (default) and `configmaps`. (default &quot;endpoints&quot;)  --leader-elect-resource-name string            The name of resource object that is used for locking during leader election. (default &quot;kube-scheduler&quot;)  --leader-elect-resource-namespace string            The namespace of resource object that is used for locking during leader election. (default &quot;kube-system&quot;)  --leader-elect-retry-period duration            The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled. (default 2s)</code></pre></blockquote><p>发现确实有相关的选项，针对<code>scheduler</code>来说，默认选择是使用一个endpoints，叫<code>kube-scheduler</code>来作为加锁的key，也可以修改为<code>configmaps</code>，当然名字也可以修改。而且renew这个锁的时间间隔默认是2s，这就很符合之前的日志输出了，<code>kube-scheduler</code>和<code>kube-controller-manager</code>两个组件，每个都间隔2s更新对应的endpoints，刚好看起来像是每秒都会有更新，这个和日志里输出的情况是一致的。</p><p>那具体K8S的这个选举机制是怎么工作的呢？继续分析一下代码，因为我们线上是运行的K8S的v1.16.15版本，所以下面的代码都是基于这个版本。</p><p>整体上，逻辑大致分为两部分：</p><ol><li>控制部分，主要负责确认当前是否获取到锁，Renew锁，释放锁等等控制层面操作</li><li>存储部分，主要负责存储这个锁，比如上文中的借助一个endpoint资源进行存储</li></ol><p>我们先看看<a href="https://github.com/kubernetes/kubernetes/blob/v1.16.15/cmd/kube-scheduler/app/server.go#L274">控制部分的入口</a>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> cc<span class="token punctuation">.</span>LeaderElection <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>  cc<span class="token punctuation">.</span>LeaderElection<span class="token punctuation">.</span>Callbacks <span class="token operator">=</span> leaderelection<span class="token punctuation">.</span>LeaderCallbacks<span class="token punctuation">&#123;</span>    OnStartedLeading<span class="token punctuation">:</span> run<span class="token punctuation">,</span>    OnStoppedLeading<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      klog<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"leaderelection lost"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span>  leaderElector<span class="token punctuation">,</span> err <span class="token operator">:=</span> leaderelection<span class="token punctuation">.</span><span class="token function">NewLeaderElector</span><span class="token punctuation">(</span><span class="token operator">*</span>cc<span class="token punctuation">.</span>LeaderElection<span class="token punctuation">)</span>  <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"couldn't create leader elector: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  leaderElector<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>  <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"lost lease"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>入口代码比较简单，创建<code>LeaderElector</code>并执行<code>Run()</code>，继续看看他的内部逻辑，这部分代码在<a href="https://github.com/kubernetes/kubernetes/blob/v1.16.15/staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go#L195">client-go里</a>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Run starts the leader election loop</span><span class="token keyword">func</span> <span class="token punctuation">(</span>le <span class="token operator">*</span>LeaderElector<span class="token punctuation">)</span> <span class="token function">Run</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>runtime<span class="token punctuation">.</span><span class="token function">HandleCrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Callbacks<span class="token punctuation">.</span><span class="token function">OnStoppedLeading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>le<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token comment">// ctx signalled done</span><span class="token punctuation">&#125;</span>ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Callbacks<span class="token punctuation">.</span><span class="token function">OnStartedLeading</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>le<span class="token punctuation">.</span><span class="token function">renew</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要的逻辑也比较清楚，先尝试<code>acquire</code>，如果成功，就调用回调函数并及时<code>renew</code>，而在<code>acquire</code>和<code>renew</code>这两个函数里主要的逻辑就是根据配置的时间间隔不停的尝试调用另一个<code>tryAcquireOrRenew</code>函数，我们主要看看这个函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tryAcquireOrRenew tries to acquire a leader lease if it is not already acquired,</span><span class="token comment">// else it tries to renew the lease if it has already been acquired. Returns true</span><span class="token comment">// on success else returns false.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>le <span class="token operator">*</span>LeaderElector<span class="token punctuation">)</span> <span class="token function">tryAcquireOrRenew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>now <span class="token operator">:=</span> metav1<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>leaderElectionRecord <span class="token operator">:=</span> rl<span class="token punctuation">.</span>LeaderElectionRecord<span class="token punctuation">&#123;</span>HolderIdentity<span class="token punctuation">:</span>       le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Lock<span class="token punctuation">.</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>LeaseDurationSeconds<span class="token punctuation">:</span> <span class="token function">int</span><span class="token punctuation">(</span>le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>LeaseDuration <span class="token operator">/</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">,</span>RenewTime<span class="token punctuation">:</span>            now<span class="token punctuation">,</span>AcquireTime<span class="token punctuation">:</span>          now<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 1. obtain or create the ElectionRecord</span>oldLeaderElectionRecord<span class="token punctuation">,</span> err <span class="token operator">:=</span> le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Lock<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span>errors<span class="token punctuation">.</span><span class="token function">IsNotFound</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>klog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"error retrieving resource lock %v: %v"</span><span class="token punctuation">,</span> le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Lock<span class="token punctuation">.</span><span class="token function">Describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">=</span> le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Lock<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>leaderElectionRecord<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>klog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"error initially creating leader election record: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>le<span class="token punctuation">.</span>observedRecord <span class="token operator">=</span> leaderElectionRecordle<span class="token punctuation">.</span>observedTime <span class="token operator">=</span> le<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token comment">// 2. Record obtained, check the Identity &amp; Time</span><span class="token keyword">if</span> <span class="token operator">!</span>reflect<span class="token punctuation">.</span><span class="token function">DeepEqual</span><span class="token punctuation">(</span>le<span class="token punctuation">.</span>observedRecord<span class="token punctuation">,</span> <span class="token operator">*</span>oldLeaderElectionRecord<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>le<span class="token punctuation">.</span>observedRecord <span class="token operator">=</span> <span class="token operator">*</span>oldLeaderElectionRecordle<span class="token punctuation">.</span>observedTime <span class="token operator">=</span> le<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>oldLeaderElectionRecord<span class="token punctuation">.</span>HolderIdentity<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>le<span class="token punctuation">.</span>observedTime<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>LeaseDuration<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token operator">!</span>le<span class="token punctuation">.</span><span class="token function">IsLeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"lock is held by %v and has not yet expired"</span><span class="token punctuation">,</span> oldLeaderElectionRecord<span class="token punctuation">.</span>HolderIdentity<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token comment">// 3. We're going to try to update. The leaderElectionRecord is set to it's default</span><span class="token comment">// here. Let's correct it before updating.</span><span class="token keyword">if</span> le<span class="token punctuation">.</span><span class="token function">IsLeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>leaderElectionRecord<span class="token punctuation">.</span>AcquireTime <span class="token operator">=</span> oldLeaderElectionRecord<span class="token punctuation">.</span>AcquireTimeleaderElectionRecord<span class="token punctuation">.</span>LeaderTransitions <span class="token operator">=</span> oldLeaderElectionRecord<span class="token punctuation">.</span>LeaderTransitions<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>leaderElectionRecord<span class="token punctuation">.</span>LeaderTransitions <span class="token operator">=</span> oldLeaderElectionRecord<span class="token punctuation">.</span>LeaderTransitions <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">// update the lock itself</span><span class="token keyword">if</span> err <span class="token operator">=</span> le<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Lock<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>leaderElectionRecord<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>klog<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Failed to update lock: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>le<span class="token punctuation">.</span>observedRecord <span class="token operator">=</span> leaderElectionRecordle<span class="token punctuation">.</span>observedTime <span class="token operator">=</span> le<span class="token punctuation">.</span>clock<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑也不复杂，主要也就是调用Lock存储的<code>Get()</code>、<code>Create()</code>和<code>Update</code>函数。那关于控制部分的逻辑基本就差不多了。</p><p>下面来看看存储相关的逻辑，入口代码在<a href="https://github.com/kubernetes/kubernetes/blob/v1.16.15/cmd/kube-scheduler/app/options/options.go#L261">cmd&#x2F;kube-scheduler&#x2F;app&#x2F;options&#x2F;options.go</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">makeLeaderElectionConfig</span><span class="token punctuation">(</span>config kubeschedulerconfig<span class="token punctuation">.</span>KubeSchedulerLeaderElectionConfiguration<span class="token punctuation">,</span> client clientset<span class="token punctuation">.</span>Interface<span class="token punctuation">,</span> recorder record<span class="token punctuation">.</span>EventRecorder<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>leaderelection<span class="token punctuation">.</span>LeaderElectionConfig<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>hostname<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Hostname</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unable to get hostname: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// add a uniquifier so that two processes on the same host don't accidentally both become active</span>id <span class="token operator">:=</span> hostname <span class="token operator">+</span> <span class="token string">"_"</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">NewUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>rl<span class="token punctuation">,</span> err <span class="token operator">:=</span> resourcelock<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>ResourceLock<span class="token punctuation">,</span>config<span class="token punctuation">.</span>ResourceNamespace<span class="token punctuation">,</span>config<span class="token punctuation">.</span>ResourceName<span class="token punctuation">,</span>client<span class="token punctuation">.</span><span class="token function">CoreV1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>client<span class="token punctuation">.</span><span class="token function">CoordinationV1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>resourcelock<span class="token punctuation">.</span>ResourceLockConfig<span class="token punctuation">&#123;</span>Identity<span class="token punctuation">:</span>      id<span class="token punctuation">,</span>EventRecorder<span class="token punctuation">:</span> recorder<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"couldn't create resource lock: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>leaderelection<span class="token punctuation">.</span>LeaderElectionConfig<span class="token punctuation">&#123;</span>Lock<span class="token punctuation">:</span>          rl<span class="token punctuation">,</span>LeaseDuration<span class="token punctuation">:</span> config<span class="token punctuation">.</span>LeaseDuration<span class="token punctuation">.</span>Duration<span class="token punctuation">,</span>RenewDeadline<span class="token punctuation">:</span> config<span class="token punctuation">.</span>RenewDeadline<span class="token punctuation">.</span>Duration<span class="token punctuation">,</span>RetryPeriod<span class="token punctuation">:</span>   config<span class="token punctuation">.</span>RetryPeriod<span class="token punctuation">.</span>Duration<span class="token punctuation">,</span>WatchDog<span class="token punctuation">:</span>      leaderelection<span class="token punctuation">.</span><span class="token function">NewLeaderHealthzAdaptor</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Name<span class="token punctuation">:</span>          <span class="token string">"kube-scheduler"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中最重要的调用是<code>resourcelock.New()</code>这里根据Lock的类型，创建了不同的实例，我们继续看看K8S提供了哪些类型的<a href="https://github.com/kubernetes/kubernetes/blob/v1.16.15/staging/src/k8s.io/client-go/tools/leaderelection/resourcelock/interface.go#L93">实现</a>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Manufacture will create a lock of a given type according to the input parameters</span><span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>lockType <span class="token builtin">string</span><span class="token punctuation">,</span> ns <span class="token builtin">string</span><span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">,</span> coreClient corev1<span class="token punctuation">.</span>CoreV1Interface<span class="token punctuation">,</span> coordinationClient coordinationv1<span class="token punctuation">.</span>CoordinationV1Interface<span class="token punctuation">,</span> rlc ResourceLockConfig<span class="token punctuation">)</span> <span class="token punctuation">(</span>Interface<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">switch</span> lockType <span class="token punctuation">&#123;</span><span class="token keyword">case</span> EndpointsResourceLock<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>EndpointsLock<span class="token punctuation">&#123;</span>EndpointsMeta<span class="token punctuation">:</span> metav1<span class="token punctuation">.</span>ObjectMeta<span class="token punctuation">&#123;</span>Namespace<span class="token punctuation">:</span> ns<span class="token punctuation">,</span>Name<span class="token punctuation">:</span>      name<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Client<span class="token punctuation">:</span>     coreClient<span class="token punctuation">,</span>LockConfig<span class="token punctuation">:</span> rlc<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token keyword">case</span> ConfigMapsResourceLock<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>ConfigMapLock<span class="token punctuation">&#123;</span>ConfigMapMeta<span class="token punctuation">:</span> metav1<span class="token punctuation">.</span>ObjectMeta<span class="token punctuation">&#123;</span>Namespace<span class="token punctuation">:</span> ns<span class="token punctuation">,</span>Name<span class="token punctuation">:</span>      name<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Client<span class="token punctuation">:</span>     coreClient<span class="token punctuation">,</span>LockConfig<span class="token punctuation">:</span> rlc<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token keyword">case</span> LeasesResourceLock<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token operator">&amp;</span>LeaseLock<span class="token punctuation">&#123;</span>LeaseMeta<span class="token punctuation">:</span> metav1<span class="token punctuation">.</span>ObjectMeta<span class="token punctuation">&#123;</span>Namespace<span class="token punctuation">:</span> ns<span class="token punctuation">,</span>Name<span class="token punctuation">:</span>      name<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>Client<span class="token punctuation">:</span>     coordinationClient<span class="token punctuation">,</span>LockConfig<span class="token punctuation">:</span> rlc<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Invalid lock-type %s"</span><span class="token punctuation">,</span> lockType<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单一看发现除了上面看到的<code>endpoints</code>、<code>configmaps</code>还多了个<code>leases</code>类型，具体的实现也比较简单，就用<code>endpoints</code>类型的<code>Create</code>举例吧：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Create attempts to create a LeaderElectionRecord annotation</span><span class="token keyword">func</span> <span class="token punctuation">(</span>el <span class="token operator">*</span>EndpointsLock<span class="token punctuation">)</span> <span class="token function">Create</span><span class="token punctuation">(</span>ler LeaderElectionRecord<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>recordBytes<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>ler<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span>el<span class="token punctuation">.</span>e<span class="token punctuation">,</span> err <span class="token operator">=</span> el<span class="token punctuation">.</span>Client<span class="token punctuation">.</span><span class="token function">Endpoints</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>EndpointsMeta<span class="token punctuation">.</span>Namespace<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v1<span class="token punctuation">.</span>Endpoints<span class="token punctuation">&#123;</span>ObjectMeta<span class="token punctuation">:</span> metav1<span class="token punctuation">.</span>ObjectMeta<span class="token punctuation">&#123;</span>Name<span class="token punctuation">:</span>      el<span class="token punctuation">.</span>EndpointsMeta<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>Namespace<span class="token punctuation">:</span> el<span class="token punctuation">.</span>EndpointsMeta<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span>Annotations<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>LeaderElectionRecordAnnotationKey<span class="token punctuation">:</span> <span class="token function">string</span><span class="token punctuation">(</span>recordBytes<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就非常的简单，就是调用kubeclient的Endpoints相关接口，创建一个<code>Endpoints</code>，同样的，其他动作也是类似。</p><p>到这里其实大体上整个选主的逻辑也基本搞清楚了，似乎没什么大问题。但总觉得目前提供的这两个基于<code>endpoints</code>和<code>configmaps</code>的实现不怎么优雅。因为每个Node上，<code>kube-proxy</code>需要watch<code>endpoints</code>的变化、而<code>kubelet</code>又需要watch<code>configmaps</code>的变化。无论选择哪个，Lock的不停Renew都会Push到所有的节点，这在无形中也会对集群多造成一点点压力。</p><p>其实从官方的实现也可以看的出来，<code>leases</code>类型是独立的一个资源，没用其他的组件会watch这个资源，从一定程度上能解决这个问题，可惜的是因为有平滑升级的需求，不能直接切换到<code>leases</code>类型的Lock了。所以官方也在后续1.17版本做出了一些改进，具体的可以参考：<a href="https://github.com/kubernetes/kubernetes/pull/81030">migrate leader election to lease API #81030</a>，<a href="https://github.com/kubernetes/kubernetes/pull/84084">Migrate components to EndpointsLeases leader election lock #84084</a>。</p><p>说回我们自己的业务，暂时也没有升级K8S得欲望，好在当前我们机器上不需要InCluster类型访问<code>apiserver</code>，也没有ClusterIP的需求，所以其实不需要<code>kube-proxy</code>这个组件，一不做二不休，不如直接把<code>kube-proxy</code>给下线了，正好下线之后还能去掉对<code>ipvs</code>模块的依赖，刚好也能解决上篇疯狂输出日志的问题，一举两得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2021/06/14/systemd-privatenetwork-cause-annoying-logs/&quot;&gt;上一篇Blog&lt;/a&gt;里遗留一个问题：在打开了&lt;code&gt;kube-proxy&lt;/code&gt;得tracing日志之后，除去定时同步iptables得日志之外，还出现了一些&lt;code&gt;Calling handler.OnEndpointsUpdate&lt;/code&gt;相关得日志输出，这些输出其实是不太寻常的：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;13:55:13 localhost kube-proxy[20761]: I0609 13:55:13.290051   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:14 localhost kube-proxy[20761]: I0609 13:55:14.502924   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:15 localhost kube-proxy[20761]: I0609 13:55:15.299633   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:16 localhost kube-proxy[20761]: I0609 13:55:16.515500   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:17 localhost kube-proxy[20761]: I0609 13:55:17.316952   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:18 localhost kube-proxy[20761]: I0609 13:55:18.525537   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:19 localhost kube-proxy[20761]: I0609 13:55:19.326566   20761 config.go:167] Calling handler.OnEndpointsUpdate
13:55:20 localhost kube-proxy[20761]: I0609 13:55:20.541238   20761 config.go:167] Calling handler.OnEndpointsUpdate&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;频率大约是1s一条，如果熟悉K8S的Watch-List机制的一眼就应该可以看出来原因：因为&lt;code&gt;kube-proxy&lt;/code&gt;会watch&lt;code&gt;Endpoints&lt;/code&gt;的变化，并对这些变化做相应动作，然后某些&lt;code&gt;Endpoints&lt;/code&gt;更新了之后，就触发了这条日志。其实这个机制是没有问题的，在正常的K8S集群里，这些输出也没有问题。但是在我们的集群里就有些不正常了，因为我们当前的应用场景，根本就不存在需要&lt;code&gt;Endpoints&lt;/code&gt;的情况！那到底是什么地方触发了&lt;code&gt;Endpoints&lt;/code&gt;的更新？&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://www.ichenfu.com/categories/Kubernetes/"/>
    
    
    <category term="leader-elect-resource-lock" scheme="https://www.ichenfu.com/tags/leader-elect-resource-lock/"/>
    
    <category term="endpoints" scheme="https://www.ichenfu.com/tags/endpoints/"/>
    
    <category term="leases" scheme="https://www.ichenfu.com/tags/leases/"/>
    
  </entry>
  
  <entry>
    <title>dmesg中持续打印的诡异日志追踪记</title>
    <link href="https://www.ichenfu.com/2021/06/14/systemd-privatenetwork-cause-annoying-logs/"/>
    <id>https://www.ichenfu.com/2021/06/14/systemd-privatenetwork-cause-annoying-logs/</id>
    <published>2021-06-14T09:03:37.000Z</published>
    <updated>2021-06-15T02:02:01.050Z</updated>
    
    <content type="html"><![CDATA[<p>在我们内部的一个系统是跑在K8S之上的，而这批机器上的<code>dmesg</code>日志里，老是会不停的刷下面的这个日志：</p><pre class="line-numbers language-none"><code class="language-none">03:52:42 localhost kernel: nf_conntrack: falling back to vmalloc.03:52:42 localhost kernel: IPVS: Creating netns size&#x3D;2048 id&#x3D;9771903:54:37 localhost kernel: nf_conntrack: falling back to vmalloc.03:54:37 localhost kernel: nf_conntrack: falling back to vmalloc.03:54:37 localhost kernel: IPVS: Creating netns size&#x3D;2048 id&#x3D;9772003:56:48 localhost kernel: nf_conntrack: falling back to vmalloc.03:56:48 localhost kernel: nf_conntrack: falling back to vmalloc.03:56:48 localhost kernel: IPVS: Creating netns size&#x3D;2048 id&#x3D;9772103:58:20 localhost kernel: IPVS: Creating netns size&#x3D;2048 id&#x3D;97722<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本来这些日志刷就刷了，也没什么大问题，但是呢，时间一长，因为logrotate机制，会把之前产生的日志给顶掉，导致有些时候想看之前的<code>dmesg</code>日志看不了了，这就比较难受了，终于，在当鸵鸟很长时间之后，想想还是找找原因，把这个问题解决一下。</p><span id="more"></span><p>如果直接用Google搜索<code>IPVS: Creating netns size=XXX id=XXX</code>或者<code>nf_conntrack: falling back to vmalloc</code>这些关键词，得到的解决方案不痛不痒，针对nf_conntrack，大部分的答案都是提示<code>vm.min_free_kbytes</code>比较小，需要调大这个参数，或者，<code>net.netfilter.nf_conntrack_*</code>相关的几个参数太大了，需要调小。而IPVS基本都没有什么相关的结果。所以我们还是得自己尝试解决一下。</p><p>一开始呢，就觉得大概率是K8S的问题，一方面因为这些日志，只有在跑了K8S的机器上才会出现；另外一方面因为这个<code>nf_conntrack</code>和<code>IPVS</code>和网络强相关，在K8S的Node节点上两个组件之一的<code>kube-proxy</code>，也会定期去同步一些网络配置，那很明显的<code>kube-proxy</code>嫌疑最大。于是我就配置了一下，把<code>kube-proxy</code>的日志等级开到最大，让运行中所有的tracing日志也都打印出来：</p><pre class="line-numbers language-none"><code class="language-none">22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.021677   20761 proxier.go:708] Syncing iptables rules22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.021703   20761 iptables.go:437] running iptables -N [KUBE-EXTERNAL-SERVICES -t filter]...22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.038491   20761 iptables.go:397] running iptables-restore [-w --noflush --counters]22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.040739   20761 proxier.go:687] syncProxyRules took 19.090909ms22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.040756   20761 bounded_frequency_runner.go:221] sync-runner: ran, next possible in 0s, periodic in 30s22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.109303   20761 config.go:167] Calling handler.OnEndpointsUpdate22:10:23 localhost kube-proxy[20761]: I0611 22:10:23.842263   20761 config.go:167] Calling handler.OnEndpointsUpdate22:10:25 localhost kube-proxy[20761]: I0611 22:10:25.120048   20761 config.go:167] Calling handler.OnEndpointsUpdate...22:10:51 localhost kube-proxy[20761]: I0611 22:10:51.268046   20761 config.go:167] Calling handler.OnEndpointsUpdate22:10:52 localhost kube-proxy[20761]: I0611 22:10:52.018512   20761 config.go:167] Calling handler.OnEndpointsUpdate22:10:53 localhost kube-proxy[20761]: I0611 22:10:53.040907   20761 proxier.go:708] Syncing iptables rules22:10:53 localhost kube-proxy[20761]: I0611 22:10:53.040933   20761 iptables.go:437] running iptables -N [KUBE-EXTERNAL-SERVICES -t filter]...22:10:53 localhost kube-proxy[20761]: I0611 22:10:53.056819   20761 iptables.go:397] running iptables-restore [-w --noflush --counters]22:10:53 localhost kube-proxy[20761]: I0611 22:10:53.058812   20761 proxier.go:687] syncProxyRules took 17.935822ms22:10:53 localhost kube-proxy[20761]: I0611 22:10:53.058827   20761 bounded_frequency_runner.go:221] sync-runner: ran, next possible in 0s, periodic in 30s22:10:53 localhost kube-proxy[20761]: I0611 22:10:53.278609   20761 config.go:167] Calling handler.OnEndpointsUpdate22:10:54 localhost kube-proxy[20761]: I0611 22:10:54.026900   20761 config.go:167] Calling handler.OnEndpointsUpdate22:10:55 localhost kube-proxy[20761]: I0611 22:10:55.287980   20761 config.go:167] Calling handler.OnEndpointsUpdate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从日志可以看到，确实<code>kube-proxy</code>会定时同步<code>iptables</code>的规则，但是周期不一样，<code>dmesg</code>里日志的周期大概两分钟一次，而这里每30s就会同步一次了，而且同步的时间和日志也对应不上，那其实基本就可以排除是<code>kube-proxy</code>导致的了。不过除此之外，日志里发现了比较反常的<code>Calling handler.OnEndpointsUpdate</code>的输出，频率还挺高，这个和之前的预想不太相符，这里暂时忽略了，等着下篇继续分析原因吧。</p><p>既然直接原因不是<code>kube-proxy</code>，那就得继续看看是为啥了。</p><p>于是就又仔细分析了一下<code>journalctl</code>的输出，因为掺杂了各种K8S组件的凌乱输出，日志非常乱，不过功夫不负有心人，最终还是发现了和<code>dmesg</code>输出时间高度对应的日志：</p><pre class="line-numbers language-none"><code class="language-none">03:52:42 localhost dbus[11450]: [system] Activating via systemd: service name&#x3D;&#39;org.freedesktop.hostname1&#39; unit&#x3D;&#39;dbus-org.freedesktop.hostname1.service&#39;03:52:42 localhost dbus[11450]: [system] Successfully activated service &#39;org.freedesktop.hostname1&#39;03:54:37 localhost dbus[11450]: [system] Activating via systemd: service name&#x3D;&#39;org.freedesktop.hostname1&#39; unit&#x3D;&#39;dbus-org.freedesktop.hostname1.service&#39;03:54:37 localhost dbus[11450]: [system] Successfully activated service &#39;org.freedesktop.hostname1&#39;03:56:48 localhost dbus[11450]: [system] Activating via systemd: service name&#x3D;&#39;org.freedesktop.hostname1&#39; unit&#x3D;&#39;dbus-org.freedesktop.hostname1.service&#39;03:56:48 localhost dbus[11450]: [system] Successfully activated service &#39;org.freedesktop.hostname1&#39;03:58:20 localhost dbus[11450]: [system] Activating via systemd: service name&#x3D;&#39;org.freedesktop.hostname1&#39; unit&#x3D;&#39;dbus-org.freedesktop.hostname1.service&#39;03:58:20 localhost dbus[11450]: [system] Successfully activated service &#39;org.freedesktop.hostname1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>似乎是<code>systemd-hostnamed</code>？再通过<code>journalctl -u systemd-hostnamed.service</code>看看<code>hostnamed</code>的日志：</p><pre class="line-numbers language-none"><code class="language-none">03:52:42 localhost systemd[1]: Starting Hostname Service...03:52:42 localhost systemd[1]: Started Hostname Service.03:54:37 localhost systemd[1]: Starting Hostname Service...03:54:37 localhost systemd[1]: Started Hostname Service.03:56:48 localhost systemd[1]: Starting Hostname Service...03:56:48 localhost systemd[1]: Started Hostname Service.03:58:20 localhost systemd[1]: Starting Hostname Service...03:58:20 localhost systemd[1]: Started Hostname Service.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还真是，那么问题来了：为什么<code>hostnamed</code>启动会刷两条<code>dmesg</code>日志？以及为什么<code>hostnamed</code>会这样定时启动？</p><p>先说明第二个问题吧，因为这个是已知的，我们系统的配置，都是用<code>puppet</code>这个自动化运维工具下发的，然后下发之后呢，为了防止人为的原因配置被修改了，所以又加了个Cron，定时2分钟+一小段随机时间执行，确保任何时候我们机器上的配置都是和我们预期是一样的。</p><p>而这些配置里，就包含了机器的主机名。具体的定义类似这样：</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">exec <span class="token punctuation">&#123;</span> <span class="token string-literal"><span class="token string">'set hostname'</span></span><span class="token operator">:</span>    command <span class="token operator">=></span> <span class="token string-literal"><span class="token string">"hostnamectl set-hostname $&#123;local_hostname&#125;"</span></span><span class="token punctuation">,</span>    <span class="token keyword">unless</span>  <span class="token operator">=></span> <span class="token string-literal"><span class="token string">"test `hostnamectl --static` == '$&#123;local_hostname&#125;'"</span></span><span class="token punctuation">,</span>    path    <span class="token operator">=></span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">'/usr/bin'</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">'/bin'</span></span><span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单解释下，就是每次都会执行<code>hostnamectl --static</code>命令，获得当前hostname，如果和预期不一致，就调用<code>hostnamectl set-hostname $&#123;local_hostname&#125;</code>命令把本地的hostname修改成我们期望的。</p><p>然后再来看看第一个问题，为什么<code>hostnamed</code>启动的时候会输出日志？看了下服务的service配置文件，一下就明白了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@<span class="token punctuation">]</span><span class="token comment"># cat /usr/lib/systemd/system/systemd-hostnamed.service</span><span class="token comment">#  This file is part of systemd.</span><span class="token comment">#</span><span class="token comment">#  systemd is free software; you can redistribute it and/or modify it</span><span class="token comment">#  under the terms of the GNU Lesser General Public License as published by</span><span class="token comment">#  the Free Software Foundation; either version 2.1 of the License, or</span><span class="token comment">#  (at your option) any later version.</span><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span><span class="token assign-left variable">Description</span><span class="token operator">=</span>Hostname Service<span class="token assign-left variable">Documentation</span><span class="token operator">=</span>man:systemd-hostnamed.service<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> man:hostname<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> man:machine-info<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token assign-left variable">Documentation</span><span class="token operator">=</span>http://www.freedesktop.org/wiki/Software/systemd/hostnamed<span class="token punctuation">[</span>Service<span class="token punctuation">]</span><span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/lib/systemd/systemd-hostnamed<span class="token assign-left variable">BusName</span><span class="token operator">=</span>org.freedesktop.hostname1<span class="token assign-left variable">CapabilityBoundingSet</span><span class="token operator">=</span>CAP_SYS_ADMIN<span class="token assign-left variable">WatchdogSec</span><span class="token operator">=</span>3min<span class="token assign-left variable">PrivateTmp</span><span class="token operator">=</span>yes<span class="token assign-left variable">PrivateDevices</span><span class="token operator">=</span>yes<span class="token assign-left variable">PrivateNetwork</span><span class="token operator">=</span>yes<span class="token assign-left variable">ProtectSystem</span><span class="token operator">=</span>yes<span class="token assign-left variable">ProtectHome</span><span class="token operator">=</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在Service的配置里添加了<code>PrivateNetwork=yes</code>选项，那这个选项是什么作用呢？在<code>man systemd.exec</code>里找到了对应的说明：</p><blockquote><p>PrivateNetwork&#x3D;<br>           Takes a boolean argument. If true, sets up a new network namespace for the executed processes and configures only the loopback network device “lo” inside it. No other network devices will be available to the executed process. This is<br>           useful to securely turn off network access by the executed process. Defaults to false. It is possible to run two or more units within the same private network namespace by using the JoinsNamespaceOf&#x3D; directive, see systemd.unit(5) for<br>           details. Note that this option will disconnect all socket families from the host, this includes AF_NETLINK and AF_UNIX. The latter has the effect that AF_UNIX sockets in the abstract socket namespace will become unavailable to the<br>           processes (however, those located in the file system will continue to be accessible).</p></blockquote><p>也就是说，如果打开<code>PrivateNetwork</code>，那么systemd在启动这个服务时会创建一个新的<code>network namespace</code>，来隔离这个进程和主机的network，而刚好我们的<code>hostnamed</code>不需要访问网络，所以默认情况下就加上了这个限制。这个也就能解释为啥<code>LVS模块</code>的日志提示是<code>Creating netns</code>了，因为真的是在创建一个新的ns。同理<code>nf_conntrack模块</code>的输出也是因为新ns需要一些初始化操作。</p><p>另外呢，<code>hostnamed</code>这个服务也比较特殊，因为获取或者设置hostname不是一个很常见的操作，而且因为有dbus可以在需要的时候触发启动，所以这个进程运行一段时间后没有新的请求会自动退出，具体可以看下它的<a href="https://github.com/systemd/systemd/blob/v219/src/hostname/hostnamed.c">代码</a>:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Context context <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        r <span class="token operator">=</span> <span class="token function">bus_event_loop_with_idle</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> bus<span class="token punctuation">,</span> <span class="token string">"org.freedesktop.hostname1"</span><span class="token punctuation">,</span> DEFAULT_EXIT_USEC<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">log_error_errno</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">"Failed to run event loop: %m"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> finish<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>finish<span class="token operator">:</span>        <span class="token function">context_free</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> EXIT_FAILURE <span class="token operator">:</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个<code>DEFAULT_EXIT_USEC</code>定义在其他文件中，原型是<code>#define DEFAULT_EXIT_USEC (30*USEC_PER_SEC)</code>，也就是30s。</p><p>到这里呢，问题算是理清楚了：</p><pre><code>1. 自动化运维脚本会定时check hostname，这会导致hostnamed被拉起来2. 因为hostnamed service描述里有PrivateNetwork=yes，所以systemd会创建network namespace3. 因为主机上加载了conntrack和ipvs相关模块（这个是kube-proxy需要的），模块会在netns里初始化，又因为一些参数的原因，会打印相关的日志4. hostnamed 30s后自定退出，导致下次执行会重新创建新的network namespace，如此反复</code></pre><p>那最终的解决方案也比较明白了，根据上面的情况：</p><pre><code>1. 调整自动化运维脚本，不使用hostnamectl命令获取当前主机名2. 合理调整conntrack相关参数，尽可能避免内核内存被耗尽的情况3. 因为我们的业务比较特殊，不需要kube-proxy，所以决定把kube-proxy服务停了，同时就不会依赖ipvs模块，顺便把ipvs模块也移除</code></pre><p>其实被这个PrivateXXXX选项坑了不止一次了，之前还发生过<code>PrivateTmp=yes</code>导致服务启动卡住的情况，唉一言难尽啊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我们内部的一个系统是跑在K8S之上的，而这批机器上的&lt;code&gt;dmesg&lt;/code&gt;日志里，老是会不停的刷下面的这个日志：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;03:52:42 localhost kernel: nf_conntrack: falling back to vmalloc.
03:52:42 localhost kernel: IPVS: Creating netns size&amp;#x3D;2048 id&amp;#x3D;97719
03:54:37 localhost kernel: nf_conntrack: falling back to vmalloc.
03:54:37 localhost kernel: nf_conntrack: falling back to vmalloc.
03:54:37 localhost kernel: IPVS: Creating netns size&amp;#x3D;2048 id&amp;#x3D;97720
03:56:48 localhost kernel: nf_conntrack: falling back to vmalloc.
03:56:48 localhost kernel: nf_conntrack: falling back to vmalloc.
03:56:48 localhost kernel: IPVS: Creating netns size&amp;#x3D;2048 id&amp;#x3D;97721
03:58:20 localhost kernel: IPVS: Creating netns size&amp;#x3D;2048 id&amp;#x3D;97722&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本来这些日志刷就刷了，也没什么大问题，但是呢，时间一长，因为logrotate机制，会把之前产生的日志给顶掉，导致有些时候想看之前的&lt;code&gt;dmesg&lt;/code&gt;日志看不了了，这就比较难受了，终于，在当鸵鸟很长时间之后，想想还是找找原因，把这个问题解决一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.ichenfu.com/categories/Linux/"/>
    
    
    <category term="nf_conntrack" scheme="https://www.ichenfu.com/tags/nf-conntrack/"/>
    
    <category term="netns" scheme="https://www.ichenfu.com/tags/netns/"/>
    
    <category term="systemd-hostnamed" scheme="https://www.ichenfu.com/tags/systemd-hostnamed/"/>
    
    <category term="PrivateNetwork" scheme="https://www.ichenfu.com/tags/PrivateNetwork/"/>
    
  </entry>
  
  <entry>
    <title>微星B550M迫击炮+5600X折腾记</title>
    <link href="https://www.ichenfu.com/2021/06/05/b550m-mortar-5600x-diy/"/>
    <id>https://www.ichenfu.com/2021/06/05/b550m-mortar-5600x-diy/</id>
    <published>2021-06-05T14:34:48.000Z</published>
    <updated>2021-06-09T07:06:19.660Z</updated>
    
    <content type="html"><![CDATA[<p>自己5年前配的一台电脑比较老了，在那个Intel一家独大，疯狂挤牙膏的时代，i5-6500的CPU加上微星的B150M迫击炮，也算是当时比较主流的中端配置了。不过这么多年过去了，只有4核4线程的6500确实有点孱弱了，最近明显感受到CPu性能不够用了。正好趁着今年618，终于把平台换新了，我一直是AMD Yes党，喊了这么长时间，终于入手了微星的B550M Mortar迫击炮+AMD 5600X的套装，一下子从4核4线程进化到了6核12线程，整体性能应该要强很多了。</p><p>不过好事多磨啊，好不容易等到CPU和主板快递到货，到家兴致勃勃把CPU插上主板、装上散热器，又把老的主板从机箱里换出来，原来老机器有两条8G 2400MHz的内存，虽然相比现在动辄3600MHz、4000MHz的内存频率低了点，好在我也就日常使用对内存带宽和延迟也不太敏感，这个钱就省了。另外还有传家宝1060显卡、硬盘什么的统统不用换。</p><p>本来想着一次点亮，可惜事与愿违、一度心态炸裂！一开电源，发现启动不了，主板上Debug灯卡在内存上，一动不动。这就有点小尴尬了，按理现在内存这东西兼容性都比较好，为啥会卡在内存上？一顿折腾、4个插槽、两根内存、各种插法全试了一遍、又尝试恢复CMOS到出厂设置、仍然不好使。难不成真得让AMD背锅？这AMD不Yes了啊。。赶紧去主板官方网站上找了下内存兼容性列表，另外也问了一下卖家客服，看看是啥情况。</p><span id="more"></span><p>最后客服给了个说法：升级BIOS试试。然后贴了个不需要CPU的更新BIOS的视频：</p><div>    <iframe src="//player.bilibili.com/player.html?aid=59293093&bvid=BV1ot41137Wq&cid=103330978&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div><p>这个主板拿到手需要更新BIOS我之前倒是在评论里看到过，不过他那个评论也比较老了，我心想现在买的主板，不会还是出厂BIOS版本吧。。但是不管怎么说，先升级看看吧。这个时候同事也发给我一个视频：<a href="https://www.bilibili.com/video/BV15a411F7fk?share_source=copy_web">微星b550迫击炮wifi版本出厂通病？内存兼容性不好，点不亮？超频超不上去？刷新bios即可解决！</a>，也是类似的情况，都在骂微星的这版出厂BIOS。</p><p>好吧，赶紧找了个U盘，按视频里说的，把BIOS文件放U盘里，改名字为<code>MSI.ROM</code>，插上对应的USB口，按BIOS回写按钮，嘿嘿，一切还真是按预期在走，确实BIOS更新灯和U盘指示灯在闪，看起来真的需要更新。不过有一说一这个功能还是不错的，不需要先点亮就能刷BIOS，即使BIOS刷挂了还有个挽回的方法，不错。</p><p>等了几分钟，BIOS应该是更新好了，直接重启，突然听到硬盘寻道的声音，之前这个声音是没有的！感觉有戏了！并且键盘灯也亮了，Debug灯也正常了，看起来内存识别的问题解决了。但是这个时候屏幕还不亮。好在第二个视频里提醒了一下，似乎这个主板在启动的时候如果显示器接的是DP口，会有可能不亮，但是换HDMI口就没问题。这个简单，又找了根HDMI线，一插上就亮了，能进BIOS了！</p><p>进了BIOS就简单了，把一些配置改了改，主要是启动方式和顺序啥的，保存、重启，直接就进系统了，很顺利。</p><p>这时候还剩下最后一个问题，这个DP口能用么？毕竟相比DP口而言HDMI带宽上没什么优势，而且我这个显示器因为分辨率和刷新率比较高，只能用DP口才能满血。于是就把HDMI线拔掉换上DP线，发现没问题，一切正常。到这里彻底舒了口气，可算没问题，一切正常了。</p><p>最后又加上另外一根内存，重启了几次，都没问题，正常进系统。但是有个细节还是被我观察到了，就是在BIOS自检阶段，本来应该显示一些Logo之类的，现在都不会显示，等到进了系统，需要输密码的时候，显示器才亮起来。虽然不影响使用，但肯定还是存在一些问题。这个问题应该也是视频里提到的为啥DP口没显示、HDMI能显示的原因。</p><p>既然HDMI口能用，那感觉问题不应该是主板了，会不会是显卡的问题？于是带着这个问题去搜了搜，似乎和一个UEFI的GOP特性有关，最终找到了NVIDIA的一个工具:<a href="https://www.nvidia.com/en-us/drivers/nv-uefi-update-x64/">NVIDIA GRAPHICS FIRMWARE UPDATE TOOL FOR DISPLAYPORT 1.3 AND 1.4 DISPLAYS</a>，在这个页面里，NVIDIA提到：</p><blockquote><p>Without the update, systems that are connected to a DisplayPort 1.3 &#x2F; 1.4 monitor could experience blank screens on boot until the OS loads, or could experience a hang on boot.</p></blockquote><p>和遇到的现象一样啊，显示器接到DP口上，在启动时进系统前会黑屏，直到进系统才能正常显示。于是赶紧下载了工具，运行、更新显卡的FIRMWARE。重启之后，嘿嘿，久违的主板Logo能显示了，进BIOS显示也正常。</p><p>啊，问题总算解决了。这么说起来，搞不好因为AMD很多年不换平台，导致BIOS兼容多代CPU变得困难，才搞得这么多Bug。相比Intel一代一换主板，问题确实多了点，怪不得AMD给人的印象就是不如Intel稳定。</p><p>总的来说，这次平台的切换，也折腾了不少，但是我依然要说出那六个字母！AMD Yes！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自己5年前配的一台电脑比较老了，在那个Intel一家独大，疯狂挤牙膏的时代，i5-6500的CPU加上微星的B150M迫击炮，也算是当时比较主流的中端配置了。不过这么多年过去了，只有4核4线程的6500确实有点孱弱了，最近明显感受到CPu性能不够用了。正好趁着今年618，终于把平台换新了，我一直是AMD Yes党，喊了这么长时间，终于入手了微星的B550M Mortar迫击炮+AMD 5600X的套装，一下子从4核4线程进化到了6核12线程，整体性能应该要强很多了。&lt;/p&gt;
&lt;p&gt;不过好事多磨啊，好不容易等到CPU和主板快递到货，到家兴致勃勃把CPU插上主板、装上散热器，又把老的主板从机箱里换出来，原来老机器有两条8G 2400MHz的内存，虽然相比现在动辄3600MHz、4000MHz的内存频率低了点，好在我也就日常使用对内存带宽和延迟也不太敏感，这个钱就省了。另外还有传家宝1060显卡、硬盘什么的统统不用换。&lt;/p&gt;
&lt;p&gt;本来想着一次点亮，可惜事与愿违、一度心态炸裂！一开电源，发现启动不了，主板上Debug灯卡在内存上，一动不动。这就有点小尴尬了，按理现在内存这东西兼容性都比较好，为啥会卡在内存上？一顿折腾、4个插槽、两根内存、各种插法全试了一遍、又尝试恢复CMOS到出厂设置、仍然不好使。难不成真得让AMD背锅？这AMD不Yes了啊。。赶紧去主板官方网站上找了下内存兼容性列表，另外也问了一下卖家客服，看看是啥情况。&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="B550M Mortar" scheme="https://www.ichenfu.com/tags/B550M-Mortar/"/>
    
    <category term="5600X" scheme="https://www.ichenfu.com/tags/5600X/"/>
    
  </entry>
  
  <entry>
    <title>关于URE(Unrecoverable Read Error Rate)的一些知识更新</title>
    <link href="https://www.ichenfu.com/2021/05/23/the-ure-improvements-on-todays-hard-disks/"/>
    <id>https://www.ichenfu.com/2021/05/23/the-ure-improvements-on-todays-hard-disks/</id>
    <published>2021-05-23T08:26:51.000Z</published>
    <updated>2021-06-09T07:06:19.660Z</updated>
    
    <content type="html"><![CDATA[<p>在几年前，写的一篇Blog：<a href="https://www.ichenfu.com/2016/12/04/ure/">Unrecoverable Read Error Rate (URE)</a>，主要说起硬盘的一个重要指标：不可恢复读取错误率，在当时的场景下，如果是非企业级硬盘，一般这个指标是在<code>1 bit per 10^14bit</code>这个水平，也就是说每读取<code>10^14bit</code>的数据，其中某个bit有可能就是错误的，这会导致一些问题，比如如果是组建了一个比较大的RAID5阵列，当容量越大时，如果出现硬盘损坏，就会有很大概率无法恢复数据。</p><p>当然也不是没有其他办法，比如使用RAID 6，或者购买企业级硬盘，因为企业级硬盘在当时就可以提供<code>1 bit per 10^15bit</code>的指标，这样算下来读取100TB数据都是没什么大问题的。</p><p>不过随着近几年硬盘技术的发展，机械硬盘的容量越来越大，很多桌面级硬盘已经超过了10T，很显然，如果URE这个指标继续保持原有的水准，那这个硬盘就不太合格了，那么现在这些大容量硬盘的这个指标做到了多少呢？</p><p>于是我就找了找希捷桌面级硬盘的<a href="https://www.seagate.com/www-content/datasheets/pdfs/barracuda-pro-14-tb-DS1901-10-2006CN-zh_CN.pdf">文档</a>：</p><p><img src="/images/barracuda-pro.png" alt="barracuda-pro"></p><span id="more"></span><p>从图里可以看到，在希捷大于10TB的硬盘产品中，在最大不可恢复错误&#x2F;被读数据（位）也就是URE这个指标上，已经向企业级硬盘看齐，达到了<code>1/10E15</code>，另外，考虑到硬盘厂商在标称这些指标时一般会比较保守。那么从单一的指标上看，完全可以组建超过几十TB的磁盘阵列而不用担心数据丢失，不过考虑到恢复时间等等各种因素，个人依然是不建议以RAID方式组建这种超大的磁盘阵列。</p><p>当然，虽然桌面级硬盘在某些指标上已经看齐了企业级硬盘，但实际上企业级硬盘在稳定性和数据安全性方面依然会比桌面级好很多，比如一般的桌面硬盘是不会有传输层面的CRC或者ECC功能的，但是企业级硬盘，一般都会有类似的能力。当然除了这些数据安全性相关的指标，平均故障时间等等指标也会比桌面级硬盘高出许多。关于这个话题，又是有非常多的内容了，简单的可以参考一些文档，比如Intel的这篇文档<a href="https://www.intel.com/content/dam/support/us/en/documents/server-products/Enterprise_vs_Desktop_HDDs_2.0.pdf">Enterprise-class versus Desktop-class Hard Drives</a>就在很多方面对比了桌面和企业级硬盘的区别。</p><p>从另外一个方面来说，比如需要基于这些机械硬盘开发一个企业级的存储系统，对数据的安全性要求极高，那么就不能100%的相信从磁盘上读取出的数据，在整个环节中，有太多的情况会导致读取出来的数据和当初写入的数据不相符。所以，在业务层，一般也需要考虑引入CRC等数据校验能力，通过读取并校验数据CRC，来保证数据一致性。</p><p>BTW，SSD硬盘，因为工作方式的不同，URE这些指标天生的就比机械硬盘好很多。同样以希捷的SSD为例：<br><img src="/images/nytro-ssd.png" alt="barracuda-pro"></p><p>URE这个指标是<code>1/10E17</code>，比机械盘好了两个数量级！当然代价是每GB价格也贵了很多。</p><p>总的来说，随着硬件的更新，很多曾经因为硬件产生的各种限制也会慢慢被打开。当然因为硬件的更新越来越快和特性和限制越来越多，软件层也需要适应这些变化，从而更好的利用好硬件所提供的能力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在几年前，写的一篇Blog：&lt;a href=&quot;https://www.ichenfu.com/2016/12/04/ure/&quot;&gt;Unrecoverable Read Error Rate (URE)&lt;/a&gt;，主要说起硬盘的一个重要指标：不可恢复读取错误率，在当时的场景下，如果是非企业级硬盘，一般这个指标是在&lt;code&gt;1 bit per 10^14bit&lt;/code&gt;这个水平，也就是说每读取&lt;code&gt;10^14bit&lt;/code&gt;的数据，其中某个bit有可能就是错误的，这会导致一些问题，比如如果是组建了一个比较大的RAID5阵列，当容量越大时，如果出现硬盘损坏，就会有很大概率无法恢复数据。&lt;/p&gt;
&lt;p&gt;当然也不是没有其他办法，比如使用RAID 6，或者购买企业级硬盘，因为企业级硬盘在当时就可以提供&lt;code&gt;1 bit per 10^15bit&lt;/code&gt;的指标，这样算下来读取100TB数据都是没什么大问题的。&lt;/p&gt;
&lt;p&gt;不过随着近几年硬盘技术的发展，机械硬盘的容量越来越大，很多桌面级硬盘已经超过了10T，很显然，如果URE这个指标继续保持原有的水准，那这个硬盘就不太合格了，那么现在这些大容量硬盘的这个指标做到了多少呢？&lt;/p&gt;
&lt;p&gt;于是我就找了找希捷桌面级硬盘的&lt;a href=&quot;https://www.seagate.com/www-content/datasheets/pdfs/barracuda-pro-14-tb-DS1901-10-2006CN-zh_CN.pdf&quot;&gt;文档&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/barracuda-pro.png&quot; alt=&quot;barracuda-pro&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日常折腾" scheme="https://www.ichenfu.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="SSD" scheme="https://www.ichenfu.com/tags/SSD/"/>
    
    <category term="RAID" scheme="https://www.ichenfu.com/tags/RAID/"/>
    
    <category term="URE" scheme="https://www.ichenfu.com/tags/URE/"/>
    
  </entry>
  
</feed>
